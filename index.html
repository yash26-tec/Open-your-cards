<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
  import {
    getDatabase, ref, onValue, off, get, runTransaction, serverTimestamp,
    onDisconnect, set, remove, push
  } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-database.js";
  import {
    getAuth, signInAnonymously, onAuthStateChanged,
    setPersistence, browserLocalPersistence
  } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";

  // ✅ Your config
  const firebaseConfig = {
    apiKey: "AIzaSyDDMj_YT8NRN-RYpksqjGOUTF5RzM5AgOM",
    authDomain: "power2-91fdc.firebaseapp.com",
    databaseURL: "https://power2-91fdc-default-rtdb.firebaseio.com",
    projectId: "power2-91fdc",
    storageBucket: "power2-91fdc.firebasestorage.app",
    messagingSenderId: "1096207181248",
    appId: "1:1096207181248:web:2fa473d9d8781616559425",
    measurementId: "G-ZR2CT9GRHV"
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  const auth = getAuth(app);

  // ---------------------------
  // Utilities
  // ---------------------------
  const el = (id) => document.getElementById(id);
  const show = (id) => el(id).classList.add("show");
  const hide = (id) => el(id).classList.remove("show");
  const setText = (id, v) => el(id).textContent = v;
  const clampName = (s, fallback) => (String(s||"").trim() || fallback).slice(0, 24);

  function cleanRoomId(s){
    return (String(s||"").toUpperCase().trim().replace(/[^A-Z0-9]/g, "")).slice(0, 10);
  }
  function extractRoomIdFromInput(raw){
    const s = String(raw || "").trim();
    if(!s) return "";
    if(s.includes("://") || s.startsWith("www.")){
      try{
        const u = new URL(s.startsWith("www.") ? ("https://" + s) : s);
        const fromParam = u.searchParams.get("room") || "";
        if(fromParam) return cleanRoomId(fromParam);
      }catch{}
    }
    return cleanRoomId(s);
  }

  function genRoomId(){
    const chars = "ABCDEFGHJKMNPQRSTUVWXYZ23456789";
    let out = "";
    for(let i=0;i<6;i++) out += chars[Math.floor(Math.random()*chars.length)];
    return out;
  }
  function deepClone(x){ return JSON.parse(JSON.stringify(x)); }
  function shuffle(arr){
    for(let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
  }
  function buildOrder(len){
    const order = Array.from({length:len}, (_,i)=>i);
    shuffle(order);
    return order;
  }

  // ✅ SESSION TOKEN (kept)
  function makeToken(){
    return Math.random().toString(36).slice(2) + "-" + Date.now().toString(36);
  }
  const SESSION_KEY = "party_session_token_v1";
  const sessionToken = localStorage.getItem(SESSION_KEY) || makeToken();
  localStorage.setItem(SESSION_KEY, sessionToken);

  // ---------------------------
  // Questions (Manage) - local
  // ---------------------------
  const QKEY = "party_questions_local_v2";
  const ADMIN_PASSWORD = "Admin@123";

  const SAMPLE_Q = {
    nhie:[
      "Never have I ever lied to my parents",
      "Never have I ever ghosted someone",
      "Never have I ever skipped a class",
      "Never have I ever stalked someone’s profile"
    ],
    pick:[
      {q:"Pick one", o1:"Pizza", o2:"Burger"},
      {q:"Pick one", o1:"Netflix", o2:"YouTube"},
      {q:"Pick one", o1:"Beach", o2:"Mountains"}
    ]
  };

  const questions = { nhie:[], pick:[] };

  function loadQuestions(){
    try{
      const v = JSON.parse(localStorage.getItem(QKEY));
      if(!v) throw 0;
      questions.nhie = Array.isArray(v.nhie) ? v.nhie : [];
      questions.pick = Array.isArray(v.pick) ? v.pick : [];
    }catch{
      questions.nhie = deepClone(SAMPLE_Q.nhie);
      questions.pick = deepClone(SAMPLE_Q.pick);
      saveQuestions();
    }
  }
  function saveQuestions(){
    localStorage.setItem(QKEY, JSON.stringify(questions));
  }

  // ---------------------------
  // Room doc model (UPDATED: conns map)
  // ---------------------------
  function makeNewRoomDoc({roomId, hostUid, hostName, q, hostSession}){
    const now = Date.now();
    return {
      roomId,
      status: "waiting", // waiting | playing
      hostUid,
      players: {
        p1: { uid: hostUid, name: hostName, session: hostSession, lastSeen: now },
        p2: { uid: "", name: "", session: "", lastSeen: 0 }
      },
      // ✅ Presence connections (uid -> connId -> timestamp)
      conns: {},
      mode: "nhie",
      idx: 0,
      order: buildOrder((q?.nhie||[]).length),
      questions: q || {nhie:[], pick:[]},
      state: {
        counts: {p1:0,p2:0},
        last: {p1:"—",p2:"—"},
        nhieTurn: "p1",
        nhieAnswered: {p1:false,p2:false},

        pickLast: {p1:"—",p2:"—"},
        pickTurn: "p1",
        pickAnswered: {p1:false,p2:false},
      },
      updatedAt: serverTimestamp()
    };
  }

  // ---------------------------
  // Firebase Room API (Realtime Database)
  // ---------------------------
  const RoomAPI = (() => {
    function roomRef(roomId){ return ref(db, `rooms/${roomId}`); }

    async function createRoom({hostUid, hostName, q, session}){
      for(let t=0; t<8; t++){
        const roomId = genRoomId();
        const r = roomRef(roomId);

        const res = await runTransaction(r, (current) => {
          if(current !== null) return;
          return makeNewRoomDoc({roomId, hostUid, hostName, q, hostSession: session});
        }, { applyLocally: false });

        if(res.committed){
          return { roomId, role:"p1" };
        }
      }
      throw new Error("Could not create room. Try again.");
    }

    // ✅ JOIN: now uses presence conns (REAL fix)
    async function joinRoom({roomId, uid, name, session}){
      const rid = extractRoomIdFromInput(roomId);
      if(!rid) throw new Error("Please enter Room code (example: AB12CD) OR paste full link.");

      const r = roomRef(rid);
      const pre = await get(r);
      if(!pre.exists()) throw new Error("Room not found");

      const res = await runTransaction(r, (doc) => {
        if(!doc) return;

        doc.players = doc.players || { p1:{uid:"",name:"",session:"",lastSeen:0}, p2:{uid:"",name:"",session:"",lastSeen:0} };
        doc.conns = doc.conns || {};
        const now = Date.now();

        // rejoin by uid
        if(doc.players?.p1?.uid === uid){
          doc.players.p1.name = name || doc.players.p1.name;
          doc.players.p1.session = doc.players.p1.session || session;
          doc.players.p1.lastSeen = now;
          doc.updatedAt = serverTimestamp();
          return doc;
        }
        if(doc.players?.p2?.uid === uid){
          doc.players.p2.name = name || doc.players.p2.name;
          doc.players.p2.session = doc.players.p2.session || session;
          doc.players.p2.lastSeen = now;
          doc.updatedAt = serverTimestamp();
          return doc;
        }

        // occupancy check based on active conns of p2 uid
        const p2uid = doc.players?.p2?.uid || "";
        const p2session = doc.players?.p2?.session || "";
        const p2Active = p2uid ? (doc.conns?.[p2uid] && Object.keys(doc.conns[p2uid]).length > 0) : false;

        // allow takeover if:
        // - same session (same device) OR
        // - p2 has no active connections (stuck slot)
        const sameSessionReclaim = !!p2uid && !!p2session && (p2session === session);
        const stuckSlot = !!p2uid && !p2Active;

        if(p2uid && !sameSessionReclaim && !stuckSlot) return; // full

        doc.players.p2.uid = uid;
        doc.players.p2.name = name;
        doc.players.p2.session = session;
        doc.players.p2.lastSeen = now;
        doc.updatedAt = serverTimestamp();
        return doc;
      }, { applyLocally: false });

      if(!res.committed){
        const snap = await get(r);
        if(!snap.exists()) throw new Error("Room not found");
        throw new Error("Room is full");
      }

      const doc = res.snapshot.val();
      if(doc.players?.p1?.uid === uid) return { role:"p1", roomId: rid };
      if(doc.players?.p2?.uid === uid) return { role:"p2", roomId: rid };
      throw new Error("Join failed");
    }

    function subscribeRoom(roomId, cb){
      const r = roomRef(extractRoomIdFromInput(roomId));
      const handler = (snap) => cb(snap.exists() ? snap.val() : null);
      onValue(r, handler);
      return () => off(r, "value", handler);
    }

    async function patchRoom(roomId, patchFn){
      const rid = extractRoomIdFromInput(roomId);
      const r = roomRef(rid);
      const res = await runTransaction(r, (doc) => {
        if(!doc) return doc;
        const next = patchFn(deepClone(doc));
        next.updatedAt = serverTimestamp();
        return next;
      }, { applyLocally: false });

      if(!res.committed) throw new Error("Update failed (conflict). Try again.");
    }

    async function leaveRoom(roomId, uid){
      const rid = extractRoomIdFromInput(roomId);
      const r = roomRef(rid);

      await runTransaction(r, (doc) => {
        if(!doc) return doc;

        const p1 = doc.players?.p1?.uid;
        const p2 = doc.players?.p2?.uid;

        doc.conns = doc.conns || {};
        delete doc.conns[uid]; // ✅ remove conns map for this uid (best effort)

        if(p1 === uid){
          return null; // host leaves -> delete room
        }
        if(p2 === uid){
          doc.players.p2 = {uid:"", name:"", session:"", lastSeen:0};
          doc.status = "waiting";
          doc.idx = 0;

          doc.state.last = {p1:"—",p2:"—"};
          doc.state.nhieAnswered = {p1:false,p2:false};
          doc.state.nhieTurn = "p1";

          doc.state.pickLast = {p1:"—",p2:"—"};
          doc.state.pickAnswered = {p1:false,p2:false};
          doc.state.pickTurn = "p1";

          doc.updatedAt = serverTimestamp();
          return doc;
        }
        return doc;
      }, { applyLocally: false });
    }

    return { createRoom, joinRoom, subscribeRoom, patchRoom, leaveRoom };
  })();

  // ---------------------------
  // Client state
  // ---------------------------
  const client = {
    uid: "",
    roomId: "",
    role: "",
    room: null,
    unsub: null,
    session: sessionToken,
    connId: "" // ✅ presence conn id
  };

  // ✅ Presence using conns/{uid}/{connId}
  let presenceTimer = null;
  async function stopPresence(){
    if(presenceTimer) clearInterval(presenceTimer);
    presenceTimer = null;

    // remove own conn node (best effort)
    try{
      if(client.roomId && client.uid && client.connId){
        const rid = extractRoomIdFromInput(client.roomId);
        await remove(ref(db, `rooms/${rid}/conns/${client.uid}/${client.connId}`));
      }
    }catch{}
    client.connId = "";
  }

  async function setupPresence(roomId){
    await stopPresence();
    const rid = extractRoomIdFromInput(roomId);
    if(!rid || !client.uid) return;

    // create a unique conn id
    const connRef = push(ref(db, `rooms/${rid}/conns/${client.uid}`));
    client.connId = connRef.key;

    // set + onDisconnect remove
    await set(connRef, Date.now());
    onDisconnect(connRef).remove();

    // also heartbeat update conn timestamp
    presenceTimer = setInterval(async () => {
      try{
        await set(ref(db, `rooms/${rid}/conns/${client.uid}/${client.connId}`), Date.now());
        // update lastSeen too (nice-to-have)
        await RoomAPI.patchRoom(rid, (doc) => {
          const r = client.role;
          if(doc?.players?.[r]?.uid === client.uid){
            doc.players[r].lastSeen = Date.now();
          }
          return doc;
        });
      }catch{}
    }, 12000);
  }

  function setScreen(name){
    ["screenHome","screenLobby","screenGame"].forEach(id => hide(id));
    show(name);

    const isGame = name === "screenGame";
    el("reset").disabled = !isGame;
    el("next").disabled  = !isGame;
    el("modeSeg").style.display = isGame ? "flex" : "none";
  }

  function showHomeError(msg){
    el("homeErr").style.display = msg ? "block" : "none";
    el("homeErr").textContent = msg || "";
  }
  function showLobbyError(msg){
    el("lobbyErr").style.display = msg ? "block" : "none";
    el("lobbyErr").textContent = msg || "";
  }

  function buildShareLink(roomId){
    const u = new URL(window.location.href);
    u.searchParams.set("room", cleanRoomId(roomId));
    return u.toString();
  }

  async function cleanupRoom(){
    await stopPresence();
    if(client.unsub) client.unsub();
    client.unsub = null;
    client.room = null;
    client.roomId = "";
    client.role = "";
  }

  function subscribeRoom(roomId){
    if(client.unsub) client.unsub();

    client.unsub = RoomAPI.subscribeRoom(roomId, async (doc) => {
      client.room = doc;
      if(!doc){
        await cleanupRoom();
        setScreen("screenHome");
        showHomeError("Room ended or deleted.");
        return;
      }
      renderFromRoom(doc);
    });
  }

  // ---------------------------
  // Render (unchanged, uses your existing DOM ids)
  // ---------------------------
  function getQ(room){ return room.questions || {nhie:[], pick:[]}; }
  function getCurrentItem(room){
    const q = getQ(room);
    const list = room.mode === "nhie" ? (q.nhie||[]) : (q.pick||[]);
    if(!list.length) return null;
    const realIdx = room.order?.[room.idx] ?? 0;
    return list[realIdx] ?? null;
  }
  function setProgress(room){
    const q = getQ(room);
    const total = room.mode === "nhie" ? (q.nhie||[]).length : (q.pick||[]).length;
    const pct = total ? Math.round(((room.idx+1)/total)*100) : 0;
    el("progFill").style.width = pct + "%";
  }
  function setModeUI(room){
    el("tabNhie").classList.toggle("active", room.mode === "nhie");
    el("tabPick").classList.toggle("active", room.mode === "pick");
    el("nhieArea").style.display = room.mode === "nhie" ? "block" : "none";
    el("pickArea").style.display = room.mode === "pick" ? "block" : "none";
  }

  function updateNhieUI(room){
    const a1 = room.state.last.p1 || "—";
    const a2 = room.state.last.p2 || "—";
    el("p1SelMini").textContent = (room.players.p1.name || "Player 1") + " • Selection";
    el("p2SelMini").textContent = (room.players.p2.name || "Player 2") + " • Selection";
    setText("p1SelBox", a1); setText("p2SelBox", a2);
    el("p1SelBox").classList.toggle("selected", a1 !== "—");
    el("p2SelBox").classList.toggle("selected", a2 !== "—");

    const d1 = !!room.state.nhieAnswered.p1;
    const d2 = !!room.state.nhieAnswered.p2;
    setText("p1Badge", d1 ? "Done" : "Pending");
    setText("p2Badge", d2 ? "Done" : "Pending");
    el("p1Badge").classList.toggle("done", d1);
    el("p2Badge").classList.toggle("done", d2);

    const turn = room.state.nhieTurn;
    setText("nhieTurnPill", "Turn: " + (turn==="p1" ? (room.players.p1.name||"P1") : (room.players.p2.name||"P2")));

    const both = d1 && d2;
    if(both){
      setText("nhieStatus", "Both answered ✅ Host can tap Next.");
      el("nhieHave").disabled = true;
      el("nhieNever").disabled = true;
    }else{
      const tName = turn==="p1" ? (room.players.p1.name||"P1") : (room.players.p2.name||"P2");
      setText("nhieStatus", tName + " select: I Have / I Never");
      const myTurn = client.role === turn;
      el("nhieHave").disabled = !myTurn;
      el("nhieNever").disabled = !myTurn;
    }

    const sel = room.state.last[turn];
    el("nhieHave").classList.toggle("selected", sel === "I Have");
    el("nhieNever").classList.toggle("selected", sel === "I Never");
  }

  function updatePickUI(room){
    const t = room.state.pickTurn;
    setText("pickTurnPill", "Turn: " + (t==="p1" ? (room.players.p1.name||"P1") : (room.players.p2.name||"P2")));

    const v1 = room.state.pickLast.p1 || "—";
    const v2 = room.state.pickLast.p2 || "—";
    setText("p1PickBox", v1);
    setText("p2PickBox", v2);
    el("p1PickBox").classList.toggle("selected", v1 !== "—");
    el("p2PickBox").classList.toggle("selected", v2 !== "—");

    const a1 = !!room.state.pickAnswered.p1;
    const a2 = !!room.state.pickAnswered.p2;
    const both = a1 && a2;

    if(both){
      setText("pickStatus", "Both answered ✅ Host can tap Next.");
      el("opt1Btn").disabled = true;
      el("opt2Btn").disabled = true;
    }else{
      const tName = t==="p1" ? (room.players.p1.name||"P1") : (room.players.p2.name||"P2");
      setText("pickStatus", tName + " select an option.");
      const myTurn = client.role === t;
      el("opt1Btn").disabled = !myTurn;
      el("opt2Btn").disabled = !myTurn;
    }

    const sel = room.state.pickLast[t];
    const o1 = el("opt1Btn").textContent || "Option 1";
    const o2 = el("opt2Btn").textContent || "Option 2";
    el("opt1Btn").classList.toggle("selected", sel && sel !== "—" && sel === o1);
    el("opt2Btn").classList.toggle("selected", sel && sel !== "—" && sel === o2);
  }

  function renderFromRoom(room){
    setText("lobbyRoomId", room.roomId);
    setText("lobbyP1", room.players.p1.name || "Waiting…");
    setText("lobbyP2", room.players.p2.name || "Waiting…");
    setText("lobbyRolePill", "Role: " + (client.role || "—"));
    el("shareLink").value = buildShareLink(room.roomId);

    const bothJoined = !!(room.players.p1.uid && room.players.p2.uid);
    el("startGame").disabled = !(bothJoined && client.role === "p1");

    if(room.status === "waiting"){
      setScreen("screenLobby");
      el("lobbyHint").textContent = bothJoined
        ? "Both players joined ✅ Host can start the game."
        : "Waiting for Player 2 to join…";
    }
    if(room.status === "playing"){
      setScreen("screenGame");
    }

    setText("gameRoomId", room.roomId);
    setText("gameMeRole", client.role || "—");
    if(room.status !== "playing") return;

    setText("p1Name", room.players.p1.name || "Player 1");
    setText("p2Name", room.players.p2.name || "Player 2");
    setText("p1Name2", room.players.p1.name || "Player 1");
    setText("p2Name2", room.players.p2.name || "Player 2");

    setModeUI(room);

    setText("p1Count", room.state.counts.p1 || 0);
    setText("p2Count", room.state.counts.p2 || 0);

    const nhieDone = room.state.nhieAnswered.p1 && room.state.nhieAnswered.p2;
    el("scoreP1").classList.toggle("active", room.mode==="nhie" && room.state.nhieTurn==="p1" && !nhieDone);
    el("scoreP2").classList.toggle("active", room.mode==="nhie" && room.state.nhieTurn==="p2" && !nhieDone);
    if(room.mode!=="nhie"){ el("scoreP1").classList.remove("active"); el("scoreP2").classList.remove("active"); }

    const item = getCurrentItem(room);
    const q = getQ(room);

    if(!item){
      setText("qText", "No questions yet.");
      setText("qMeta", "Open Manage → add questions");
      el("opt1Btn").textContent = "Option 1";
      el("opt2Btn").textContent = "Option 2";
      setProgress(room);
      updateNhieUI(room);
      updatePickUI(room);
      return;
    }

    if(room.mode === "nhie"){
      setText("qText", item);
      setText("qMeta", `Never Have I Ever • ${room.idx+1}/${(q.nhie||[]).length}`);
      setProgress(room);
      updateNhieUI(room);
    }else{
      const qq = item.q?.trim() ? item.q.trim() : "Pick one";
      setText("qText", qq);
      setText("qMeta", `Pick One • ${room.idx+1}/${(q.pick||[]).length}`);
      el("opt1Btn").textContent = item.o1 || "Option 1";
      el("opt2Btn").textContent = item.o2 || "Option 2";
      setProgress(room);
      updatePickUI(room);
    }

    el("next").disabled = !(client.role==="p1");
    el("reset").disabled = !(client.role==="p1");
  }

  // ---------------------------
  // Room flows
  // ---------------------------
  async function createRoomFlow(){
    showHomeError("");
    const myName = clampName(el("myNameCreate").value, "Player 1");

    try{
      const q = deepClone(questions);
      const { roomId, role } = await RoomAPI.createRoom({
        hostUid: client.uid,
        hostName: myName,
        q,
        session: client.session
      });

      client.role = role;
      client.roomId = roomId;

      setText("topSub", "Room created. Share link and wait for friend.");
      subscribeRoom(roomId);
      await setupPresence(roomId); // ✅ presence
    }catch(err){
      console.error(err);
      showHomeError(err?.message || "Failed to create room");
    }
  }

  async function joinRoomFlow(roomIdFromUrl){
    showHomeError("");
    const raw = roomIdFromUrl || el("roomIdJoin").value || "";
    const myName = clampName(el("myNameJoin").value, "Player 2");
    const rid = extractRoomIdFromInput(raw);
    if(!rid) return showHomeError("Please enter Room code or paste full link.");

    try{
      const { role, roomId: realRid } = await RoomAPI.joinRoom({
        roomId: raw,
        uid: client.uid,
        name: myName,
        session: client.session
      });
      client.role = role;
      client.roomId = realRid;

      setText("topSub", "Joined room. Waiting for host to start.");
      subscribeRoom(realRid);
      await setupPresence(realRid); // ✅ presence
    }catch(err){
      console.error(err);
      showHomeError(err?.message || "Failed to join room");
    }
  }

  async function startGameFlow(){
    showLobbyError("");
    if(client.role !== "p1") return;
    if(!client.roomId) return;

    try{
      const q = deepClone(questions);

      await RoomAPI.patchRoom(client.roomId, (doc) => {
        const both = doc.players.p1.uid && doc.players.p2.uid;
        if(!both) return doc;

        doc.questions = q;
        doc.status = "playing";
        doc.mode = doc.mode || "nhie";

        const len = doc.mode === "nhie" ? (q.nhie||[]).length : (q.pick||[]).length;
        doc.order = buildOrder(len);
        doc.idx = 0;

        doc.state.last = {p1:"—",p2:"—"};
        doc.state.nhieAnswered = {p1:false,p2:false};
        doc.state.nhieTurn = "p1";

        doc.state.pickLast = {p1:"—",p2:"—"};
        doc.state.pickAnswered = {p1:false,p2:false};
        doc.state.pickTurn = "p1";

        return doc;
      });
    }catch(err){
      console.error(err);
      showLobbyError(err?.message || "Cannot start");
    }
  }

  async function leaveRoomFlow(){
    try{
      if(client.roomId){
        await RoomAPI.leaveRoom(client.roomId, client.uid);
      }
    }catch(e){
      console.error(e);
    }
    await cleanupRoom();
    setScreen("screenHome");
  }

  async function setMode(mode){
    if(client.role !== "p1") return;
    if(!client.roomId) return;

    await RoomAPI.patchRoom(client.roomId, (doc) => {
      doc.mode = mode;

      const q = doc.questions || {nhie:[], pick:[]};
      const len = mode === "nhie" ? (q.nhie||[]).length : (q.pick||[]).length;
      doc.order = buildOrder(len);
      doc.idx = 0;

      doc.state.last = {p1:"—",p2:"—"};
      doc.state.nhieAnswered = {p1:false,p2:false};
      doc.state.nhieTurn = "p1";

      doc.state.pickLast = {p1:"—",p2:"—"};
      doc.state.pickAnswered = {p1:false,p2:false};
      doc.state.pickTurn = "p1";

      return doc;
    });
  }

  async function nhieSelect(answerText){
    if(!client.roomId) return;

    await RoomAPI.patchRoom(client.roomId, (doc) => {
      if(doc.status !== "playing") return doc;
      if(doc.mode !== "nhie") return doc;

      const turn = doc.state.nhieTurn;
      if(client.role !== turn) return doc;
      if(doc.state.nhieAnswered[turn]) return doc;

      doc.state.last[turn] = answerText;
      doc.state.nhieAnswered[turn] = true;

      if(answerText === "I Have"){
        doc.state.counts[turn] = (doc.state.counts[turn] || 0) + 1;
      }

      const other = (turn === "p1") ? "p2" : "p1";
      if(!doc.state.nhieAnswered[other]){
        doc.state.nhieTurn = other;
      }
      return doc;
    });
  }

  async function pickSelect(optionText){
    if(!client.roomId) return;

    await RoomAPI.patchRoom(client.roomId, (doc) => {
      if(doc.status !== "playing") return doc;
      if(doc.mode !== "pick") return doc;

      const turn = doc.state.pickTurn;
      if(client.role !== turn) return doc;
      if(doc.state.pickAnswered[turn]) return doc;

      doc.state.pickLast[turn] = optionText;
      doc.state.pickAnswered[turn] = true;

      const other = (turn === "p1") ? "p2" : "p1";
      if(!doc.state.pickAnswered[other]){
        doc.state.pickTurn = other;
      }
      return doc;
    });
  }

  async function nextQuestion(){
    if(client.role !== "p1") return;
    if(!client.roomId) return;

    await RoomAPI.patchRoom(client.roomId, (doc) => {
      if(doc.status !== "playing") return doc;

      const q = doc.questions || {nhie:[], pick:[]};
      const len = doc.mode === "nhie" ? (q.nhie||[]).length : (q.pick||[]).length;
      if(!len) return doc;

      if(doc.mode === "nhie"){
        if(!(doc.state.nhieAnswered.p1 && doc.state.nhieAnswered.p2)) return doc;
      }else{
        if(!(doc.state.pickAnswered.p1 && doc.state.pickAnswered.p2)) return doc;
      }

      doc.idx = (doc.idx + 1) % len;

      doc.state.last = {p1:"—",p2:"—"};
      doc.state.nhieAnswered = {p1:false,p2:false};
      doc.state.nhieTurn = "p1";

      doc.state.pickLast = {p1:"—",p2:"—"};
      doc.state.pickAnswered = {p1:false,p2:false};
      doc.state.pickTurn = "p1";

      return doc;
    });
  }

  async function resetGame(){
    if(client.role !== "p1") return;
    if(!client.roomId) return;

    await RoomAPI.patchRoom(client.roomId, (doc) => {
      const q = doc.questions || {nhie:[], pick:[]};
      const len = doc.mode === "nhie" ? (q.nhie||[]).length : (q.pick||[]).length;

      doc.state.counts = {p1:0,p2:0};
      doc.idx = 0;
      doc.order = buildOrder(len);

      doc.state.last = {p1:"—",p2:"—"};
      doc.state.nhieAnswered = {p1:false,p2:false};
      doc.state.nhieTurn = "p1";

      doc.state.pickLast = {p1:"—",p2:"—"};
      doc.state.pickAnswered = {p1:false,p2:false};
      doc.state.pickTurn = "p1";

      return doc;
    });
  }

  // ---------------------------
  // Manage Sheet (unchanged from your code)
  // ---------------------------
  function escapeHtml(s){
    return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#039;");
  }

  function renderLists(){
    el("nhieList").innerHTML = questions.nhie.length
      ? questions.nhie.map((q,i)=>`
        <div class="listItem">
          <div>${escapeHtml(q)}</div>
          <button class="del" data-del-nhie="${i}">Delete</button>
        </div>
      `).join("")
      : `<div class="tiny">No NHIE questions.</div>`;

    el("pickList").innerHTML = questions.pick.length
      ? questions.pick.map((p,i)=>`
        <div class="listItem">
          <div><b>${escapeHtml(p.o1||"Option 1")}</b> vs <b>${escapeHtml(p.o2||"Option 2")}</b></div>
          <button class="del" data-del-pick="${i}">Delete</button>
        </div>
      `).join("")
      : `<div class="tiny">No Pick One questions.</div>`;
  }

  function openSheet(){
    el("overlay").classList.add("show");
    const unlocked = localStorage.getItem("admin_unlocked_firebase")==="1";
    el("adminLogin").style.display = unlocked ? "none" : "block";
    el("adminPanel").style.display = unlocked ? "block" : "none";
    if(unlocked) renderLists();
    el("adminPass").value = "";
    el("adminPass").setAttribute("readonly","readonly");
    setTimeout(()=>el("adminPass").blur(), 0);
  }
  function closeSheet(){ el("overlay").classList.remove("show"); }

  // ---------------------------
  // Wire events (same ids as your HTML)
  // ---------------------------
  el("btnCreateRoom").addEventListener("click", createRoomFlow);
  el("btnJoinRoom").addEventListener("click", () => joinRoomFlow(""));

  el("startGame").addEventListener("click", startGameFlow);
  el("leaveRoom").addEventListener("click", leaveRoomFlow);

  el("copyLink").addEventListener("click", async () => {
    try{
      await navigator.clipboard.writeText(el("shareLink").value);
      el("copyLink").textContent = "Copied ✅";
      setTimeout(()=> el("copyLink").textContent = "Copy Link", 900);
    }catch{
      el("shareLink").select();
      document.execCommand("copy");
    }
  });

  el("tabNhie").addEventListener("click", ()=> setMode("nhie"));
  el("tabPick").addEventListener("click", ()=> setMode("pick"));

  el("nhieHave").addEventListener("click", ()=> nhieSelect("I Have"));
  el("nhieNever").addEventListener("click", ()=> nhieSelect("I Never"));

  el("opt1Btn").addEventListener("click", ()=> pickSelect(el("opt1Btn").textContent || "Option 1"));
  el("opt2Btn").addEventListener("click", ()=> pickSelect(el("opt2Btn").textContent || "Option 2"));

  el("next").addEventListener("click", nextQuestion);
  el("reset").addEventListener("click", resetGame);

  el("openAdmin").addEventListener("click", openSheet);
  el("closeSheet").addEventListener("click", closeSheet);

  el("adminPass").addEventListener("pointerdown", ()=> el("adminPass").removeAttribute("readonly"));
  el("adminPass").addEventListener("focus", ()=> el("adminPass").removeAttribute("readonly"));

  el("unlock").addEventListener("click", ()=>{
    const pass = (el("adminPass").value || "").trim();
    if(pass === ADMIN_PASSWORD){
      localStorage.setItem("admin_unlocked_firebase","1");
      el("adminLogin").style.display = "none";
      el("adminPanel").style.display = "block";
      renderLists();
    }else{
      alert("Wrong password");
    }
  });

  el("addNhie").addEventListener("click", ()=>{
    const v = (el("nhieNew").value || "").trim();
    if(!v) return;
    questions.nhie.unshift(v);
    el("nhieNew").value="";
    saveQuestions(); renderLists();
  });

  el("clearNhie").addEventListener("click", ()=>{
    if(!confirm("Clear all NHIE questions?")) return;
    questions.nhie = [];
    saveQuestions(); renderLists();
  });

  el("addPick").addEventListener("click", ()=>{
    const q = (el("pickQ").value || "").trim() || "Pick one";
    const o1 = (el("pickO1").value || "").trim();
    const o2 = (el("pickO2").value || "").trim();
    if(!o1 || !o2) return alert("Fill both options.");
    questions.pick.unshift({q,o1,o2});
    el("pickQ").value=""; el("pickO1").value=""; el("pickO2").value="";
    saveQuestions(); renderLists();
  });

  el("clearPick").addEventListener("click", ()=>{
    if(!confirm("Clear all Pick One questions?")) return;
    questions.pick = [];
    saveQuestions(); renderLists();
  });

  el("loadSample").addEventListener("click", ()=>{
    questions.nhie = deepClone(SAMPLE_Q.nhie);
    questions.pick = deepClone(SAMPLE_Q.pick);
    saveQuestions(); renderLists();
    alert("Sample loaded ✅");
  });

  el("wipeAll").addEventListener("click", ()=>{
    if(!confirm("Reset EVERYTHING?")) return;
    localStorage.removeItem(QKEY);
    localStorage.removeItem("admin_unlocked_firebase");
    localStorage.removeItem(SESSION_KEY);
    location.reload();
  });

  el("overlay").addEventListener("click", (e)=>{
    const dn = e.target?.getAttribute?.("data-del-nhie");
    const dp = e.target?.getAttribute?.("data-del-pick");
    if(dn != null){
      questions.nhie.splice(Number(dn),1);
      saveQuestions(); renderLists();
    }
    if(dp != null){
      questions.pick.splice(Number(dp),1);
      saveQuestions(); renderLists();
    }
  });

  // ---------------------------
  // Boot
  // ---------------------------
  function bootUI(){
    loadQuestions();
    setScreen("screenHome");

    const url = new URL(window.location.href);
    const roomFromUrl = cleanRoomId(url.searchParams.get("room") || "");
    if(roomFromUrl){
      el("roomIdJoin").value = roomFromUrl;
      setText("topSub", "Room link opened. Enter your name & Join.");
      setTimeout(()=> el("myNameJoin").focus(), 250);
    }
  }

  // ✅ Auth stable
  setPersistence(auth, browserLocalPersistence).then(()=>{
    return signInAnonymously(auth);
  }).catch((e)=>{
    console.error(e);
    showHomeError("Auth error: " + (e?.message || "unknown"));
  });

  onAuthStateChanged(auth, (user) => {
    if(!user) return;
    client.uid = user.uid;
    el("authInfo").textContent = "Connected (uid: " + user.uid.slice(0,8) + "…)";
    bootUI();
  });
</script>
