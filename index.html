<script type="module">
  // Firebase (CDN ESM)
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
  import {
    getDatabase, ref, onValue, off, get, runTransaction, serverTimestamp
  } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-database.js";
  import {
    getAuth, signInAnonymously, onAuthStateChanged,
    setPersistence, browserLocalPersistence
  } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";

  // ✅ Your config
  const firebaseConfig = {
    apiKey: "AIzaSyDDMj_YT8NRN-RYpksqjGOUTF5RzM5AgOM",
    authDomain: "power2-91fdc.firebaseapp.com",
    databaseURL: "https://power2-91fdc-default-rtdb.firebaseio.com",
    projectId: "power2-91fdc",
    storageBucket: "power2-91fdc.firebasestorage.app",
    messagingSenderId: "1096207181248",
    appId: "1:1096207181248:web:2fa473d9d8781616559425",
    measurementId: "G-ZR2CT9GRHV"
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  const auth = getAuth(app);

  // ---------------------------
  // Utilities
  // ---------------------------
  const el = (id) => document.getElementById(id);
  const show = (id) => el(id).classList.add("show");
  const hide = (id) => el(id).classList.remove("show");
  const setText = (id, v) => el(id).textContent = v;

  const clampName = (s, fallback) => (String(s||"").trim() || fallback).slice(0, 24);

  function cleanRoomId(s){
    return (String(s||"").toUpperCase().trim().replace(/[^A-Z0-9]/g, "")).slice(0, 10);
  }

  // ✅ Accept "CODE" OR "full link"
  function extractRoomIdFromInput(raw){
    const s = String(raw || "").trim();
    if(!s) return "";
    if(s.includes("://") || s.startsWith("www.")){
      try{
        const u = new URL(s.startsWith("www.") ? ("https://" + s) : s);
        const fromParam = u.searchParams.get("room") || "";
        if(fromParam) return cleanRoomId(fromParam);
      }catch{}
    }
    return cleanRoomId(s);
  }

  function genRoomId(){
    const chars = "ABCDEFGHJKMNPQRSTUVWXYZ23456789";
    let out = "";
    for(let i=0;i<6;i++) out += chars[Math.floor(Math.random()*chars.length)];
    return out;
  }

  function deepClone(x){ return JSON.parse(JSON.stringify(x)); }

  function shuffle(arr){
    for(let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
  }
  function buildOrder(len){
    const order = Array.from({length:len}, (_,i)=>i);
    shuffle(order);
    return order;
  }

  // ✅ SESSION TOKEN (fixes “room full” when UID changes)
  function makeToken(){
    return Math.random().toString(36).slice(2) + "-" + Date.now().toString(36);
  }
  const SESSION_KEY = "party_session_token_v1";
  const sessionToken = localStorage.getItem(SESSION_KEY) || makeToken();
  localStorage.setItem(SESSION_KEY, sessionToken);

  // ---------------------------
  // Questions (Manage) - local
  // ---------------------------
  const QKEY = "party_questions_local_v2";
  const ADMIN_PASSWORD = "Admin@123";

  const SAMPLE_Q = {
    nhie:[
      "Never have I ever lied to my parents",
      "Never have I ever ghosted someone",
      "Never have I ever skipped a class",
      "Never have I ever stalked someone’s profile"
    ],
    pick:[
      {q:"Pick one", o1:"Pizza", o2:"Burger"},
      {q:"Pick one", o1:"Netflix", o2:"YouTube"},
      {q:"Pick one", o1:"Beach", o2:"Mountains"}
    ]
  };

  const questions = { nhie:[], pick:[] };

  function loadQuestions(){
    try{
      const v = JSON.parse(localStorage.getItem(QKEY));
      if(!v) throw 0;
      questions.nhie = Array.isArray(v.nhie) ? v.nhie : [];
      questions.pick = Array.isArray(v.pick) ? v.pick : [];
    }catch{
      questions.nhie = deepClone(SAMPLE_Q.nhie);
      questions.pick = deepClone(SAMPLE_Q.pick);
      saveQuestions();
    }
  }
  function saveQuestions(){
    localStorage.setItem(QKEY, JSON.stringify(questions));
  }

  // ---------------------------
  // Room doc model
  // ---------------------------
  function makeNewRoomDoc({roomId, hostUid, hostName, q, hostSession}){
    return {
      roomId,
      status: "waiting",
      hostUid,
      players: {
        p1: { uid: hostUid, name: hostName, session: hostSession },
        p2: { uid: "", name: "", session: "" }
      },
      mode: "nhie",
      idx: 0,
      order: buildOrder((q?.nhie||[]).length),
      questions: q || {nhie:[], pick:[]},
      state: {
        counts: {p1:0,p2:0},
        last: {p1:"—",p2:"—"},
        nhieTurn: "p1",
        nhieAnswered: {p1:false,p2:false},

        pickLast: {p1:"—",p2:"—"},
        pickTurn: "p1",
        pickAnswered: {p1:false,p2:false},
      },
      updatedAt: serverTimestamp()
    };
  }

  // ---------------------------
  // Firebase Room API
  // ---------------------------
  const RoomAPI = (() => {
    function roomRef(roomId){ return ref(db, `rooms/${roomId}`); }

    async function createRoom({hostUid, hostName, q, session}){
      for(let t=0; t<8; t++){
        const roomId = genRoomId();
        const r = roomRef(roomId);

        const res = await runTransaction(r, (current) => {
          if(current !== null) return;
          return makeNewRoomDoc({roomId, hostUid, hostName, q, hostSession: session});
        }, { applyLocally: false });

        if(res.committed){
          return { roomId, role:"p1" };
        }
      }
      throw new Error("Could not create room. Try again.");
    }

    // ✅ JOIN: allow reclaim by SAME session token even if UID changed
    async function joinRoom({roomId, uid, name, session}){
      const rid = extractRoomIdFromInput(roomId);
      if(!rid) throw new Error("Please enter Room code (example: AB12CD) OR paste full link.");

      const r = roomRef(rid);

      const pre = await get(r);
      if(!pre.exists()) throw new Error("Room not found");

      const res = await runTransaction(r, (doc) => {
        if(!doc) return;

        // ensure sessions exist
        doc.players = doc.players || {p1:{uid:"",name:"",session:""}, p2:{uid:"",name:"",session:""}};
        doc.players.p1.session = doc.players.p1.session || "";
        doc.players.p2.session = doc.players.p2.session || "";

        // rejoin allowed (same uid)
        if(doc.players?.p1?.uid === uid){
          doc.players.p1.name = name || doc.players.p1.name;
          doc.players.p1.session = doc.players.p1.session || session;
          doc.updatedAt = serverTimestamp();
          return doc;
        }
        if(doc.players?.p2?.uid === uid){
          doc.players.p2.name = name || doc.players.p2.name;
          doc.players.p2.session = doc.players.p2.session || session;
          doc.updatedAt = serverTimestamp();
          return doc;
        }

        const p2uid = doc.players?.p2?.uid || "";
        const p2session = doc.players?.p2?.session || "";

        // ✅ reclaim slot if same device/browser session
        const sameSessionReclaim = !!p2uid && p2session && (p2session === session) && doc.status === "waiting";

        // if full and not reclaim => abort
        if(p2uid && !sameSessionReclaim) return;

        // join / reclaim as p2
        doc.players.p2.uid = uid;
        doc.players.p2.name = name;
        doc.players.p2.session = session;
        doc.updatedAt = serverTimestamp();
        return doc;
      }, { applyLocally: false });

      if(!res.committed){
        const snap = await get(r);
        if(!snap.exists()) throw new Error("Room not found");
        throw new Error("Room is full");
      }

      const doc = res.snapshot.val();
      if(doc.players?.p1?.uid === uid) return { role:"p1", roomId: rid };
      if(doc.players?.p2?.uid === uid) return { role:"p2", roomId: rid };
      throw new Error("Join failed");
    }

    function subscribeRoom(roomId, cb){
      const r = roomRef(extractRoomIdFromInput(roomId));
      const handler = (snap) => cb(snap.exists() ? snap.val() : null);
      onValue(r, handler);
      return () => off(r, "value", handler);
    }

    async function patchRoom(roomId, patchFn){
      const rid = extractRoomIdFromInput(roomId);
      const r = roomRef(rid);
      const res = await runTransaction(r, (doc) => {
        if(!doc) return doc;
        const next = patchFn(deepClone(doc));
        next.updatedAt = serverTimestamp();
        return next;
      }, { applyLocally: false });

      if(!res.committed) throw new Error("Update failed (conflict). Try again.");
    }

    async function leaveRoom(roomId, uid){
      const rid = extractRoomIdFromInput(roomId);
      const r = roomRef(rid);

      await runTransaction(r, (doc) => {
        if(!doc) return doc;

        const p1 = doc.players?.p1?.uid;
        const p2 = doc.players?.p2?.uid;

        if(p1 === uid){
          return null; // host leaves -> delete room
        }
        if(p2 === uid){
          doc.players.p2 = {uid:"", name:"", session:""};
          doc.status = "waiting";
          doc.idx = 0;

          doc.state.last = {p1:"—",p2:"—"};
          doc.state.nhieAnswered = {p1:false,p2:false};
          doc.state.nhieTurn = "p1";

          doc.state.pickLast = {p1:"—",p2:"—"};
          doc.state.pickAnswered = {p1:false,p2:false};
          doc.state.pickTurn = "p1";

          doc.updatedAt = serverTimestamp();
          return doc;
        }
        return doc;
      }, { applyLocally: false });
    }

    return { createRoom, joinRoom, subscribeRoom, patchRoom, leaveRoom };
  })();

  // ---------------------------
  // Client state
  // ---------------------------
  const client = {
    uid: "",
    roomId: "",
    role: "",
    room: null,
    unsub: null,
    session: sessionToken
  };

  function setScreen(name){
    ["screenHome","screenLobby","screenGame"].forEach(id => hide(id));
    show(name);

    const isGame = name === "screenGame";
    el("reset").disabled = !isGame;
    el("next").disabled  = !isGame;
    el("modeSeg").style.display = isGame ? "flex" : "none";
  }

  function showHomeError(msg){
    el("homeErr").style.display = msg ? "block" : "none";
    el("homeErr").textContent = msg || "";
  }
  function showLobbyError(msg){
    el("lobbyErr").style.display = msg ? "block" : "none";
    el("lobbyErr").textContent = msg || "";
  }

  function buildShareLink(roomId){
    const u = new URL(window.location.href);
    u.searchParams.set("room", cleanRoomId(roomId));
    return u.toString();
  }

  function cleanupRoom(){
    if(client.unsub) client.unsub();
    client.unsub = null;
    client.room = null;
    client.roomId = "";
    client.role = "";
  }

  function subscribeRoom(roomId){
    if(client.unsub) client.unsub();
    client.unsub = RoomAPI.subscribeRoom(roomId, (doc) => {
      client.room = doc;
      if(!doc){
        cleanupRoom();
        setScreen("screenHome");
        showHomeError("Room ended or deleted.");
        return;
      }
      renderFromRoom(doc);
    });
  }

  // ---------------------------
  // Render (same as your existing render)
  // ---------------------------
  function getQ(room){ return room.questions || {nhie:[], pick:[]}; }
  function getCurrentItem(room){
    const q = getQ(room);
    const list = room.mode === "nhie" ? (q.nhie||[]) : (q.pick||[]);
    if(!list.length) return null;
    const realIdx = room.order?.[room.idx] ?? 0;
    return list[realIdx] ?? null;
  }
  function setProgress(room){
    const q = getQ(room);
    const total = room.mode === "nhie" ? (q.nhie||[]).length : (q.pick||[]).length;
    const pct = total ? Math.round(((room.idx+1)/total)*100) : 0;
    el("progFill").style.width = pct + "%";
  }
  function setModeUI(room){
    el("tabNhie").classList.toggle("active", room.mode === "nhie");
    el("tabPick").classList.toggle("active", room.mode === "pick");
    el("nhieArea").style.display = room.mode === "nhie" ? "block" : "none";
    el("pickArea").style.display = room.mode === "pick" ? "block" : "none";
  }

  function updateNhieUI(room){
    const a1 = room.state.last.p1 || "—";
    const a2 = room.state.last.p2 || "—";
    el("p1SelMini").textContent = (room.players.p1.name || "Player 1") + " • Selection";
    el("p2SelMini").textContent = (room.players.p2.name || "Player 2") + " • Selection";
    setText("p1SelBox", a1); setText("p2SelBox", a2);
    el("p1SelBox").classList.toggle("selected", a1 !== "—");
    el("p2SelBox").classList.toggle("selected", a2 !== "—");

    const d1 = !!room.state.nhieAnswered.p1;
    const d2 = !!room.state.nhieAnswered.p2;
    setText("p1Badge", d1 ? "Done" : "Pending");
    setText("p2Badge", d2 ? "Done" : "Pending");
    el("p1Badge").classList.toggle("done", d1);
    el("p2Badge").classList.toggle("done", d2);

    const turn = room.state.nhieTurn;
    setText("nhieTurnPill", "Turn: " + (turn==="p1" ? (room.players.p1.name||"P1") : (room.players.p2.name||"P2")));

    const both = d1 && d2;
    if(both){
      setText("nhieStatus", "Both answered ✅ Host can tap Next.");
      el("nhieHave").disabled = true;
      el("nhieNever").disabled = true;
    }else{
      const tName = turn==="p1" ? (room.players.p1.name||"P1") : (room.players.p2.name||"P2");
      setText("nhieStatus", tName + " select: I Have / I Never");
      const myTurn = client.role === turn;
      el("nhieHave").disabled = !myTurn;
      el("nhieNever").disabled = !myTurn;
    }

    const sel = room.state.last[turn];
    el("nhieHave").classList.toggle("selected", sel === "I Have");
    el("nhieNever").classList.toggle("selected", sel === "I Never");
  }

  function updatePickUI(room){
    const t = room.state.pickTurn;
    setText("pickTurnPill", "Turn: " + (t==="p1" ? (room.players.p1.name||"P1") : (room.players.p2.name||"P2")));

    const v1 = room.state.pickLast.p1 || "—";
    const v2 = room.state.pickLast.p2 || "—";
    setText("p1PickBox", v1);
    setText("p2PickBox", v2);
    el("p1PickBox").classList.toggle("selected", v1 !== "—");
    el("p2PickBox").classList.toggle("selected", v2 !== "—");

    const a1 = !!room.state.pickAnswered.p1;
    const a2 = !!room.state.pickAnswered.p2;
    const both = a1 && a2;

    if(both){
      setText("pickStatus", "Both answered ✅ Host can tap Next.");
      el("opt1Btn").disabled = true;
      el("opt2Btn").disabled = true;
    }else{
      const tName = t==="p1" ? (room.players.p1.name||"P1") : (room.players.p2.name||"P2");
      setText("pickStatus", tName + " select an option.");
      const myTurn = client.role === t;
      el("opt1Btn").disabled = !myTurn;
      el("opt2Btn").disabled = !myTurn;
    }

    const sel = room.state.pickLast[t];
    const o1 = el("opt1Btn").textContent || "Option 1";
    const o2 = el("opt2Btn").textContent || "Option 2";
    el("opt1Btn").classList.toggle("selected", sel && sel !== "—" && sel === o1);
    el("opt2Btn").classList.toggle("selected", sel && sel !== "—" && sel === o2);
  }

  function renderFromRoom(room){
    setText("lobbyRoomId", room.roomId);
    setText("lobbyP1", room.players.p1.name || "Waiting…");
    setText("lobbyP2", room.players.p2.name || "Waiting…");
    setText("lobbyRolePill", "Role: " + (client.role || "—"));
    el("shareLink").value = buildShareLink(room.roomId);

    const bothJoined = !!(room.players.p1.uid && room.players.p2.uid);
    el("startGame").disabled = !(bothJoined && client.role === "p1");

    if(room.status === "waiting"){
      setScreen("screenLobby");
      el("lobbyHint").textContent = bothJoined
        ? "Both players joined ✅ Host can start the game."
        : "Waiting for Player 2 to join…";
    }
    if(room.status === "playing"){
      setScreen("screenGame");
    }

    setText("gameRoomId", room.roomId);
    setText("gameMeRole", client.role || "—");

    if(room.status !== "playing") return;

    setText("p1Name", room.players.p1.name || "Player 1");
    setText("p2Name", room.players.p2.name || "Player 2");
    setText("p1Name2", room.players.p1.name || "Player 1");
    setText("p2Name2", room.players.p2.name || "Player 2");

    setModeUI(room);

    setText("p1Count", room.state.counts.p1 || 0);
    setText("p2Count", room.state.counts.p2 || 0);

    const nhieDone = room.state.nhieAnswered.p1 && room.state.nhieAnswered.p2;
    el("scoreP1").classList.toggle("active", room.mode==="nhie" && room.state.nhieTurn==="p1" && !nhieDone);
    el("scoreP2").classList.toggle("active", room.mode==="nhie" && room.state.nhieTurn==="p2" && !nhieDone);
    if(room.mode!=="nhie"){ el("scoreP1").classList.remove("active"); el("scoreP2").classList.remove("active"); }

    const item = getCurrentItem(room);
    const q = getQ(room);

    if(!item){
      setText("qText", "No questions yet.");
      setText("qMeta", "Open Manage → add questions");
      el("opt1Btn").textContent = "Option 1";
      el("opt2Btn").textContent = "Option 2";
      setProgress(room);
      updateNhieUI(room);
      updatePickUI(room);
      return;
    }

    if(room.mode === "nhie"){
      setText("qText", item);
      setText("qMeta", `Never Have I Ever • ${room.idx+1}/${(q.nhie||[]).length}`);
      setProgress(room);
      updateNhieUI(room);
    }else{
      const qq = item.q?.trim() ? item.q.trim() : "Pick one";
      setText("qText", qq);
      setText("qMeta", `Pick One • ${room.idx+1}/${(q.pick||[]).length}`);
      el("opt1Btn").textContent = item.o1 || "Option 1";
      el("opt2Btn").textContent = item.o2 || "Option 2";
      setProgress(room);
      updatePickUI(room);
    }

    el("next").disabled = !(client.role==="p1");
    el("reset").disabled = !(client.role==="p1");
  }

  // ---------------------------
  // Room flows
  // ---------------------------
  async function createRoomFlow(){
    showHomeError("");
    const myName = clampName(el("myNameCreate").value, "Player 1");
    try{
      const q = deepClone(questions);
      const { roomId, role } = await RoomAPI.createRoom({
        hostUid: client.uid,
        hostName: myName,
        q,
        session: client.session
      });
      client.role = role;
      client.roomId = roomId;
      setText("topSub", "Room created. Share link and wait for friend.");
      subscribeRoom(roomId);
    }catch(err){
      console.error(err);
      showHomeError(err?.message || "Failed to create room");
    }
  }

  async function joinRoomFlow(roomIdFromUrl){
    showHomeError("");
    const raw = roomIdFromUrl || el("roomIdJoin").value || "";
    const myName = clampName(el("myNameJoin").value, "Player 2");
    try{
      const { role, roomId: rid } = await RoomAPI.joinRoom({
        roomId: raw,
        uid: client.uid,
        name: myName,
        session: client.session
      });
      client.role = role;
      client.roomId = rid;
      setText("topSub", "Joined room. Waiting for host to start.");
      subscribeRoom(rid);
    }catch(err){
      console.error(err);
      showHomeError(err?.message || "Failed to join room");
    }
  }

  // ---- REST OF YOUR EVENTS + GAME LOGIC ----
  // ✅ yaha se neeche tumhara existing code SAME rahega
  // (startGameFlow, leaveRoomFlow, setMode, nhieSelect, pickSelect, nextQuestion, resetGame, manage sheet, wire events, boot UI)

  // ---------------------------
  // (KEEP your remaining code BELOW exactly as earlier)
  // ---------------------------

  // ... PASTE your remaining functions/events here (unchanged) ...

  // ---------------------------
  // Boot (Auth + URL join hint)
  // ---------------------------
  function bootUI(){
    loadQuestions();
    setScreen("screenHome");

    const url = new URL(window.location.href);
    const roomFromUrl = cleanRoomId(url.searchParams.get("room") || "");
    if(roomFromUrl){
      el("roomIdJoin").value = roomFromUrl;
      setText("topSub", "Room link opened. Enter your name & Join.");
      setTimeout(()=> el("myNameJoin").focus(), 250);
    }
  }

  // ✅ Anonymous auth (stable uid across refresh)
  setPersistence(auth, browserLocalPersistence).then(()=>{
    return signInAnonymously(auth);
  }).catch((e)=>{
    console.error(e);
    showHomeError("Auth error: " + (e?.message || "unknown"));
  });

  onAuthStateChanged(auth, (user) => {
    if(!user) return;
    client.uid = user.uid;
    el("authInfo").textContent = "Connected (uid: " + user.uid.slice(0,8) + "…)";
    bootUI();
  });

</script>
