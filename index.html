<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>2P Party Game (Supabase Rooms) â€” FINAL (Pink/Red + Shuffle + Truth/Dare + Chat)</title>
  <style>
    :root{
      /* âœ… Pinkish-Red Theme */
      --bg:#fff1f6;            /* pink-50 */
      --card:#ffffff;
      --stroke:#ffd1e1;        /* soft pink stroke */
      --blue:#db2777;          /* pink-600 */
      --blue2:#ef4444;         /* red-500 */
      --txt:#0f172a;
      --muted:#6b7280;
      --shadow: 0 10px 26px rgba(15,23,42,.08);
      --r:18px;
    }
    *{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    body{
      margin:0; min-height:100dvh;
      background:
        radial-gradient(1100px 520px at 50% -25%, rgba(219,39,119,.22), transparent 55%),
        radial-gradient(700px 380px at 0% 0%, rgba(239,68,68,.12), transparent 60%),
        linear-gradient(180deg,var(--bg),#fff);
      color:var(--txt);
      display:flex; justify-content:center; align-items:flex-start;
      padding:14px;
    }
    .app{width:min(520px,100%);display:grid;gap:12px;padding-bottom:96px}
    .topbar{
      background:rgba(255,255,255,.92);
      border:1px solid var(--stroke);
      border-radius:var(--r);
      box-shadow:var(--shadow);
      padding:12px;
      backdrop-filter: blur(10px);
    }
    .titleRow{display:flex;justify-content:space-between;align-items:flex-start;gap:10px}
    h1{margin:0;font-size:16px;letter-spacing:.2px}
    .sub{margin-top:4px;color:var(--muted);font-size:12px;line-height:1.3}

    .seg{
      display:flex;gap:8px;margin-top:10px;
      background:linear-gradient(180deg,#ffe4ee,#fff5f8);
      padding:6px;border-radius:999px;border:1px solid var(--stroke)
    }
    .seg button{
      flex:1;border:0;border-radius:999px;padding:10px;cursor:pointer;background:transparent;
      color:var(--muted);font-weight:1000;letter-spacing:.2px
    }
    .seg button.active{
      background:linear-gradient(135deg,var(--blue),var(--blue2));
      color:#fff;box-shadow:0 10px 20px rgba(219,39,119,.22)
    }

    .card{
      background:rgba(255,255,255,.92);
      border:1px solid var(--stroke);
      border-radius:var(--r);
      box-shadow:var(--shadow);
      padding:12px;
      backdrop-filter: blur(10px);
      overflow:hidden;
    }

    .qBox{
      border:1px dashed #f7b3cf;
      background:linear-gradient(180deg,#fff7fb,#ffffff);
      border-radius:16px;
      padding:14px;
      min-height:110px;
      display:flex;flex-direction:column;justify-content:center;gap:8px;
      position:relative;
    }
    .qText{font-size:18px;font-weight:1000;line-height:1.25}
    .qMeta{font-size:12px;color:var(--muted);display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center}

    .prog{
      height:8px;border-radius:999px;background:#ffe8f1;border:1px solid var(--stroke);
      overflow:hidden; flex:1; min-width:140px;
    }
    .prog > i{
      display:block;height:100%;
      width:0%;
      background:linear-gradient(135deg,var(--blue),var(--blue2));
      border-radius:999px;
      box-shadow:0 10px 22px rgba(219,39,119,.20);
      transition:width .25s ease;
    }

    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}

    .btn{
      border:1px solid var(--stroke);
      background:linear-gradient(180deg,#ffffff,#fff7fb);
      color:var(--txt);
      border-radius:16px;
      padding:12px 12px;
      font-weight:1000;
      cursor:pointer;
      box-shadow:0 6px 14px rgba(15,23,42,.06);
      transition:transform .06s ease, box-shadow .12s ease, filter .12s ease;
      user-select:none;
      position:relative;
      overflow:hidden;
    }
    .btn:hover{filter:brightness(1.02)}
    .btn:active{transform:scale(.99)}
    .btn:disabled{opacity:.45; cursor:not-allowed; transform:none}
    .btn::after{
      content:"";
      position:absolute; inset:-60% -30% auto -30%;
      height:120%; transform:rotate(20deg);
      background:linear-gradient(90deg, transparent, rgba(255,255,255,.45), transparent);
      opacity:.0;
      transition:opacity .18s ease;
    }
    .btn:hover::after{opacity:.55}
    .btn.selected{
      background:linear-gradient(135deg,var(--blue),var(--blue2));
      color:#fff;border:0;
      box-shadow:0 14px 30px rgba(219,39,119,.26);
    }
    .btn.selected::after{opacity:.22}
    .btn.ghost{background:linear-gradient(180deg,#ffeaf2,#ffffff)}
    .btn.danger{
      background:linear-gradient(180deg,#fff5f7,#ffffff);
      border:1px solid #ffd2da;color:#b91c1c
    }

    .pill{
      font-size:12px;padding:6px 10px;border-radius:999px;
      border:1px solid rgba(219,39,119,.20);
      background:rgba(219,39,119,.10);
      color:#9d174d;
      font-weight:1000
    }

    input{
      width:100%;
      border:1px solid var(--stroke);
      border-radius:16px;
      padding:12px;
      background:#fff;
      outline:none;
      box-shadow:0 6px 14px rgba(15,23,42,.04);
    }

    .bottomBar{
      position:fixed;left:0;right:0;bottom:0;
      background:rgba(255,255,255,.9);
      backdrop-filter: blur(10px);
      border-top:1px solid var(--stroke);
      padding:10px;
      padding-bottom: calc(10px + env(safe-area-inset-bottom));
      display:flex;justify-content:center
    }
    .bottomInner{width:min(520px,100%);display:flex;gap:10px}
    .bottomInner .btn{flex:1}

    .overlay{position:fixed;inset:0;background:rgba(15,23,42,.45);display:none;align-items:flex-end;justify-content:center;padding:14px}
    .overlay.show{display:flex}
    .sheet{
      width:min(520px,100%);
      background:rgba(255,255,255,.96);
      border-radius:20px;
      border:1px solid var(--stroke);
      box-shadow:0 18px 55px rgba(0,0,0,.25);
      padding:12px;
      max-height:82vh;
      overflow:auto;
      backdrop-filter: blur(12px);
    }
    .sheetTop{display:flex;justify-content:space-between;align-items:center;gap:10px}
    .sheetTitle{font-weight:1000}
    .xbtn{border:1px solid var(--stroke);background:#fff;border-radius:14px;padding:10px 12px;cursor:pointer;font-weight:1000}
    .hint{font-size:12px;color:var(--muted);margin:8px 0 10px;line-height:1.35}
    .divider{height:1px;background:#ffe3ef;margin:12px 0}
    .grid{display:grid;gap:10px}
    .miniRow{display:flex;gap:10px}
    .miniRow > *{flex:1}
    .list{margin-top:10px;border:1px solid var(--stroke);border-radius:16px;padding:10px;background:#fff7fb}
    .listItem{display:flex;justify-content:space-between;gap:10px;padding:10px;border-radius:14px;background:#fff;border:1px solid var(--stroke);margin-bottom:8px;font-size:13px;align-items:flex-start}
    .listItem:last-child{margin-bottom:0}
    .del{border:1px solid #ffd2da;background:#fff5f7;color:#b91c1c;border-radius:14px;padding:8px 10px;cursor:pointer;font-weight:1000;white-space:nowrap}
    .tiny{font-size:12px;color:var(--muted)}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}

    .scoreGrid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px}
    .scoreCard{
      border:1px solid var(--stroke);
      border-radius:18px;
      padding:12px;
      background:linear-gradient(180deg,#ffffff,#fff7fb);
      box-shadow:0 10px 22px rgba(15,23,42,.06);
      position:relative;
      overflow:hidden;
      transition:transform .10s ease, box-shadow .12s ease;
    }
    .scoreTop{display:flex;justify-content:space-between;align-items:flex-start;gap:8px}
    .scoreName{font-weight:1000;font-size:13px}
    .scoreNum{font-size:32px;font-weight:1000;color:var(--blue);line-height:1}
    .scoreCard.active{
      transform:translateY(-1px);
      box-shadow:0 16px 36px rgba(219,39,119,.14);
      border-color:rgba(219,39,119,.35);
    }
    .scoreCard.active::before{
      content:"";
      position:absolute; inset:0;
      background:radial-gradient(280px 140px at 20% 0%, rgba(219,39,119,.18), transparent 60%);
      pointer-events:none;
    }

    .nhieSelectedGrid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px}
    .selCard{
      border:1px solid var(--stroke);
      border-radius:18px;
      padding:12px;
      background:linear-gradient(180deg,#ffffff,#fff7fb);
      box-shadow:0 8px 18px rgba(15,23,42,.05);
      display:grid; gap:8px;
    }
    .selHeader{display:flex;justify-content:space-between;align-items:center;gap:10px}
    .selMini{font-size:12px;color:var(--muted);font-weight:900}
    .selBadge{
      font-size:12px; padding:6px 10px; border-radius:999px;
      border:1px solid var(--stroke); background:#fff;
      font-weight:1000; color:var(--muted);
    }
    .selBadge.done{
      border:1px solid rgba(219,39,119,.25);
      background:rgba(219,39,119,.10);
      color:#9d174d;
    }
    .selValue{
      font-size:16px;font-weight:1000;line-height:1.2;
      padding:12px 12px;border-radius:14px;
      border:1px solid var(--stroke); background:#fff;
    }
    .selValue.selected{
      border:1px solid rgba(219,39,119,.25);
      background:rgba(219,39,119,.10);
      color:#9d174d;
    }

    .actionBoard{
      margin-top:10px;border:1px solid var(--stroke);
      border-radius:18px;padding:12px;
      background:linear-gradient(180deg,#ffffff,#fff5f9);
      display:grid; gap:10px;
    }
    .actionHeader{display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap}
    .status{font-size:12px;color:var(--muted)}
    .bigRow{display:flex;gap:10px}
    .bigRow .btn{flex:1;padding:14px;border-radius:18px;font-size:14px}

    .pickSelectedGrid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px}
    .pickSelCard{
      border:1px solid var(--stroke);
      border-radius:18px;
      padding:12px;
      background:linear-gradient(180deg,#ffffff,#fff7fb);
      box-shadow:0 8px 18px rgba(15,23,42,.05);
    }
    .pickSelName{font-weight:1000;font-size:13px}
    .pickSelValue{
      margin-top:8px;font-size:18px;font-weight:1000;line-height:1.2;
      padding:12px 12px;border-radius:14px;border:1px solid var(--stroke);background:#fff;
    }
    .pickSelValue.selected{
      border:1px solid rgba(219,39,119,.25);
      background:rgba(219,39,119,.10);
      color:#9d174d;
    }

    /* âœ… Truth/Dare + Chat UI */
    .tdBoard{
      margin-top:10px;border:1px solid var(--stroke);
      border-radius:18px;padding:12px;
      background:linear-gradient(180deg,#ffffff,#fff5f9);
      display:grid; gap:10px;
    }
    .tdTop{
      display:flex;justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap;
    }
    .tdWho{
      display:flex;gap:8px;flex-wrap:wrap;align-items:center;
    }
    .cardsGrid{
      display:grid;
      grid-template-columns:1fr;
      gap:10px;
    }
    .cardBtn{
      text-align:left;
      padding:12px;
      border-radius:16px;
      border:1px solid var(--stroke);
      background:#fff;
      box-shadow:0 8px 18px rgba(15,23,42,.05);
      cursor:pointer;
      font-weight:1000;
      line-height:1.25;
    }
    .cardBtn:hover{filter:brightness(1.01)}
    .cardBtn:disabled{opacity:.50; cursor:not-allowed}
    .cardBtn.selected{
      background:rgba(219,39,119,.10);
      border-color:rgba(219,39,119,.25);
      color:#9d174d;
    }

    /* âœ… Attractive Spin Wheel (UPDATED: 8 slices + center SPIN button like image) */
    .wheelWrap{
      display:grid;
      place-items:center;
      gap:10px;
      padding:6px 0 2px;
    }
    .wheelStage{
      position:relative;
      width:240px;
      height:240px;
      display:grid;
      place-items:center;
    }
    .wheel{
      width:240px;height:240px;border-radius:50%;
      border:10px solid rgba(255,255,255,.75);
      box-shadow:
        0 22px 50px rgba(219,39,119,.18),
        0 10px 22px rgba(15,23,42,.08);

      background:
        conic-gradient(
          #8b5cf6 0 45deg,
          #ec4899 45deg 90deg,
          #f97316 90deg 135deg,
          #facc15 135deg 180deg,
          #84cc16 180deg 225deg,
          #22c55e 225deg 270deg,
          #06b6d4 270deg 315deg,
          #3b82f6 315deg 360deg
        );

      position:relative;
      transform:rotate(0deg);
      transition:transform 2.5s cubic-bezier(.12,.85,.22,1);
      overflow:hidden;
    }
    .wheel::before{
      content:"";
      position:absolute; inset:10px;
      border-radius:50%;
      background:
        radial-gradient(120px 120px at 30% 25%, rgba(255,255,255,.45), transparent 55%),
        radial-gradient(160px 120px at 70% 75%, rgba(255,255,255,.18), transparent 55%);
      mix-blend-mode:screen;
      pointer-events:none;
    }
    .wheel::after{
      content:"";
      position:absolute; inset:0;
      border-radius:50%;
      background:
        radial-gradient(closest-side, rgba(255,255,255,.22), transparent 62%),
        radial-gradient(closest-side, rgba(0,0,0,.06), transparent 70%);
      pointer-events:none;
    }

    /* keep pointer */
    .wheelPointer{
      position:absolute;
      top:-6px; left:50%;
      transform:translateX(-50%);
      width:0;height:0;
      border-left:14px solid transparent;
      border-right:14px solid transparent;
      border-bottom:26px solid #ffffff;
      filter:drop-shadow(0 10px 14px rgba(15,23,42,.18));
    }
    .wheelPointer::after{
      content:"";
      position:absolute;
      left:-10px; top:6px;
      width:20px;height:20px;border-radius:50%;
      background:linear-gradient(135deg,var(--blue),var(--blue2));
      border:2px solid #fff;
      box-shadow:0 10px 18px rgba(219,39,119,.22);
    }

    /* âœ… Center SPIN button */
    .spinCenter{
      position:absolute;
      width:92px;height:92px;border-radius:50%;
      border:10px solid #fff;
      background:#ffffff;
      color:#7c3aed;
      font-weight:1000;
      letter-spacing:.8px;
      text-transform:uppercase;
      box-shadow:0 14px 30px rgba(15,23,42,.18);
      cursor:pointer;
      display:grid;
      place-items:center;
      user-select:none;
    }
    .spinCenter:disabled{
      opacity:.55;
      cursor:not-allowed;
    }
    .spinCenter:active{ transform:scale(.98); }

    /* keep badge */
    .tdBadge{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      padding:10px 14px;
      border-radius:999px;
      font-weight:1000;
      letter-spacing:.8px;
      text-transform:uppercase;
      border:1px solid rgba(219,39,119,.25);
      background:rgba(255,255,255,.75);
      box-shadow:0 10px 22px rgba(15,23,42,.06);
      width:fit-content;
      margin:0 auto;
    }
    .tdBadge.big{
      font-size:16px;
      padding:12px 18px;
    }
    .tdBadge.truth{
      background:rgba(219,39,119,.12);
      color:#9d174d;
    }
    .tdBadge.dare{
      background:rgba(239,68,68,.10);
      color:#b91c1c;
    }

    .chatBox{
      margin-top:10px;
      border:1px solid var(--stroke);
      border-radius:18px;
      background:linear-gradient(180deg,#ffffff,#fff7fb);
      box-shadow:0 10px 22px rgba(15,23,42,.06);
      overflow:hidden;
    }
    .chatHead{
      padding:10px 12px;
      display:flex;justify-content:space-between;align-items:center;gap:10px;
      border-bottom:1px solid #ffe3ef;
      background:rgba(255,255,255,.75);
    }
    .chatTitle{font-weight:1000}
    .chatMsgs{
      padding:10px 12px;
      max-height:220px;
      overflow:auto;
      display:grid; gap:8px;
    }
    .msg{
      border:1px solid var(--stroke);
      border-radius:14px;
      padding:10px;
      background:#fff;
      font-size:13px;
      line-height:1.3;
    }
    .msgTop{
      display:flex;justify-content:space-between;gap:10px;align-items:center;
      margin-bottom:4px;
    }
    .msgName{font-weight:1000;color:#9d174d}
    .msgTime{font-size:11px;color:var(--muted);white-space:nowrap}
    .chatSend{
      padding:10px 12px;
      border-top:1px solid #ffe3ef;
      display:flex;gap:10px;
      background:rgba(255,255,255,.75);
    }
    .chatSend input{flex:1}
    .chatSend .btn{flex:0 0 auto; padding:12px 14px}

    .screen{display:none}
    .screen.show{display:block}

    .roomCard{
      border:1px solid var(--stroke);
      border-radius:18px;
      padding:12px;
      background:linear-gradient(180deg,#ffffff,#fff7fb);
      box-shadow:0 10px 22px rgba(15,23,42,.06);
      display:grid; gap:10px;
    }
    .roomTitle{font-weight:1000}
    .roomLine{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .copyRow{display:flex;gap:10px}
    .copyRow .btn{flex:0 0 auto; padding:10px 12px}
    .copyRow input{flex:1}
    .centerNote{font-size:12px;color:var(--muted);line-height:1.35}
  </style>
</head>
<body>
  <div class="app">

    <div class="topbar">
      <div class="titleRow">
        <div>
          <h1>2-Player Party Game</h1>
          <div class="sub" id="topSub">Supabase realtime rooms enabled âœ…</div>
        </div>
        <button class="btn ghost" id="openAdmin">Manage</button>
      </div>

      <div class="seg" id="modeSeg" style="display:none;">
        <button id="tabNhie" class="active">Never Have I Ever</button>
        <button id="tabPick">Pick One</button>
        <button id="tabTD">Truth / Dare</button>
      </div>
    </div>

    <!-- HOME -->
    <div class="card screen show" id="screenHome">
      <div class="roomCard">
        <div class="roomTitle">Play with a friend (real-time)</div>
        <div class="centerNote">
          Create room â†’ share link â†’ friend joins â†’ host starts â†’ live sync.
        </div>

        <div class="divider"></div>

        <div class="grid">
          <div class="hint"><b>Create Room</b></div>
          <input id="myNameCreate" placeholder="Your name" />
          <button class="btn selected" id="btnCreateRoom">Create Room</button>
        </div>

        <div class="divider"></div>

        <div class="grid">
          <div class="hint"><b>Join Room</b></div>
          <input id="roomIdJoin" placeholder="Room code (e.g. AB12CD)" />
          <input id="myNameJoin" placeholder="Your name" />
          <button class="btn" id="btnJoinRoom">Join Room</button>
        </div>

        <div class="tiny" id="homeErr" style="display:none;color:#b91c1c;font-weight:900;"></div>
        <div class="tiny" id="authInfo" style="margin-top:6px;"></div>
      </div>
    </div>

    <!-- LOBBY -->
    <div class="card screen" id="screenLobby">
      <div class="roomCard">
        <div class="roomTitle">Room Lobby</div>

        <div class="roomLine">
          <span class="pill">Room</span>
          <span class="mono" id="lobbyRoomId">â€”</span>
          <span class="pill" id="lobbyRolePill">Role: â€”</span>
        </div>

        <div class="copyRow">
          <input id="shareLink" readonly />
          <button class="btn selected" id="copyLink">Copy Link</button>
        </div>

        <div class="divider"></div>

        <div class="grid">
          <div class="hint">Players</div>
          <div class="scoreGrid">
            <div class="scoreCard">
              <div class="scoreTop">
                <div class="scoreName" id="lobbyP1">Waitingâ€¦</div>
                <div class="pill">P1</div>
              </div>
            </div>
            <div class="scoreCard">
              <div class="scoreTop">
                <div class="scoreName" id="lobbyP2">Waitingâ€¦</div>
                <div class="pill">P2</div>
              </div>
            </div>
          </div>
          <div class="centerNote" id="lobbyHint">Waiting for Player 2 to joinâ€¦</div>
        </div>

        <div class="row" style="justify-content:space-between">
          <button class="btn danger" id="leaveRoom">Leave</button>
          <button class="btn selected" id="startGame" disabled>Start Game</button>
        </div>

        <div class="tiny" id="lobbyErr" style="display:none;color:#b91c1c;font-weight:900;"></div>
      </div>
    </div>

    <!-- GAME -->
    <div class="card screen" id="screenGame">
      <div class="qBox">
        <div class="qText" id="qText">Loadingâ€¦</div>
        <div class="qMeta">
          <span id="qMeta">â€”</span>
          <div class="prog" aria-hidden="true"><i id="progFill"></i></div>
        </div>
      </div>

      <!-- NHIE -->
      <div id="nhieArea">
        <div class="scoreGrid">
          <div class="scoreCard" id="scoreP1">
            <div class="scoreTop">
              <div class="scoreName" id="p1Name">Player 1</div>
              <div class="scoreNum" id="p1Count">0</div>
            </div>
          </div>
          <div class="scoreCard" id="scoreP2">
            <div class="scoreTop">
              <div class="scoreName" id="p2Name">Player 2</div>
              <div class="scoreNum" id="p2Count">0</div>
            </div>
          </div>
        </div>

        <div class="nhieSelectedGrid">
          <div class="selCard">
            <div class="selHeader">
              <div class="selMini" id="p1SelMini">Player 1 â€¢ Selection</div>
              <span class="selBadge" id="p1Badge">Pending</span>
            </div>
            <div class="selValue" id="p1SelBox">â€”</div>
          </div>

          <div class="selCard">
            <div class="selHeader">
              <div class="selMini" id="p2SelMini">Player 2 â€¢ Selection</div>
              <span class="selBadge" id="p2Badge">Pending</span>
            </div>
            <div class="selValue" id="p2SelBox">â€”</div>
          </div>
        </div>

        <div class="actionBoard">
          <div class="actionHeader">
            <span class="pill" id="nhieTurnPill">Turn: â€”</span>
            <span class="status" id="nhieStatus">Select your answer.</span>
          </div>
          <div class="bigRow">
            <button class="btn" id="nhieHave">I Have</button>
            <button class="btn" id="nhieNever">I Never</button>
          </div>
        </div>
      </div>

      <!-- PICK -->
      <div id="pickArea" style="display:none; margin-top:10px;">
        <div class="row" style="justify-content:space-between; align-items:center;">
          <span class="pill" id="pickTurnPill">Turn: â€”</span>
          <span class="tiny" id="pickStatus">Select an option.</span>
        </div>

        <div class="row" style="margin-top:10px;">
          <button class="btn" id="opt1Btn" style="flex:1;">Option 1</button>
          <button class="btn" id="opt2Btn" style="flex:1;">Option 2</button>
        </div>

        <div class="pickSelectedGrid">
          <div class="pickSelCard">
            <div class="pickSelName" id="p1Name2">Player 1</div>
            <div class="pickSelValue" id="p1PickBox">â€”</div>
          </div>
          <div class="pickSelCard">
            <div class="pickSelName" id="p2Name2">Player 2</div>
            <div class="pickSelValue" id="p2PickBox">â€”</div>
          </div>
        </div>

        <div class="tiny" style="margin-top:8px;">Pick One has no score. Only selections are shown.</div>
      </div>

      <!-- TRUTH / DARE -->
      <div id="tdArea" style="display:none; margin-top:10px;">
        <div class="tdBoard">
          <div class="tdTop">
            <div class="tdWho">
              <span class="pill" id="tdTurnPill">Turn: â€”</span>
              <span class="pill" id="tdPhasePill">Phase: â€”</span>
            </div>

            <!-- âœ… Spin button removed from top row (now in center of wheel) -->
            <div class="row" style="gap:8px">
              <button class="btn" id="tdShuffleBtn">ðŸ”€ Shuffle</button>
              <button class="btn ghost" id="tdNextBtn">Next Spin</button>
            </div>
          </div>

          <!-- âœ… Big TRUTH/DARE result badge (separate, prominent) -->
          <div class="tdBadge big" id="tdResultBadge">â€”</div>

          <!-- âœ… Attractive wheel -->
          <div class="wheelWrap">
            <div class="wheelStage">
              <div class="wheelPointer" aria-hidden="true"></div>
              <div class="wheel" id="wheel"></div>

              <!-- âœ… CENTER SPIN BUTTON -->
              <button class="spinCenter" id="tdSpinBtn" type="button">SPIN</button>
            </div>
            <div class="tiny" id="tdHint">â€”</div>
          </div>

          <div class="cardsGrid" id="tdCards"></div>
        </div>

        <div class="chatBox">
          <div class="chatHead">
            <div class="chatTitle">ðŸ’¬ Chat</div>
            <div class="tiny" id="chatMeta">Last 40 messages</div>
          </div>
          <div class="chatMsgs" id="chatMsgs"></div>
          <div class="chatSend">
            <input id="chatInput" placeholder="Type a messageâ€¦" maxlength="220"/>
            <button class="btn selected" id="chatSendBtn">Send</button>
          </div>
        </div>
      </div>

      <div class="tiny" style="margin-top:10px;">
        Room: <span class="mono" id="gameRoomId">â€”</span> â€¢ You are: <span class="mono" id="gameMeRole">â€”</span>
      </div>
    </div>

  </div>

  <div class="bottomBar" id="bottomBar">
    <div class="bottomInner">
      <button class="btn ghost" id="reset">Reset</button>
      <button class="btn selected" id="next">Next</button>
    </div>
  </div>

  <!-- Manage Sheet -->
  <div class="overlay" id="overlay">
    <div class="sheet">
      <div class="sheetTop">
        <div class="sheetTitle">Manage</div>
        <button class="xbtn" id="closeSheet">âœ•</button>
      </div>

      <div id="adminLogin">
        <div class="hint">Password required</div>

        <form autocomplete="off" onsubmit="return false;">
          <input type="text" style="display:none" autocomplete="username">
          <input type="password" style="display:none" autocomplete="new-password">

          <div class="row">
            <input id="adminPass"
                   type="password"
                   placeholder="Password"
                   name="admin_pass__no_fill"
                   autocomplete="new-password"
                   inputmode="text"
                   autocapitalize="none"
                   autocorrect="off"
                   spellcheck="false"
                   data-lpignore="true"
                   data-1p-ignore="true"
                   readonly />
            <button class="btn selected" id="unlock" type="button">Unlock</button>
          </div>
        </form>
      </div>

      <div id="adminPanel" style="display:none;">
        <div class="hint">Manage questions here (saved on this phone).</div>

        <!-- âœ… Shuffle controls -->
        <div class="divider"></div>
        <div class="grid">
          <div class="hint"><b>Order settings</b></div>

          <label class="listItem" style="align-items:center;">
            <div>
              <div style="font-weight:1000;">Shuffle Never Have I Ever</div>
              <div class="tiny">ON = random order â€¢ OFF = normal order</div>
            </div>
            <input type="checkbox" id="shuffleNhie" checked style="width:auto; transform:scale(1.2);" />
          </label>

          <label class="listItem" style="align-items:center;">
            <div>
              <div style="font-weight:1000;">Shuffle Pick One</div>
              <div class="tiny">ON = random order â€¢ OFF = normal order</div>
            </div>
            <input type="checkbox" id="shufflePick" checked style="width:auto; transform:scale(1.2);" />
          </label>

          <div class="tiny">Note: Shuffle applies on Create Room / Start / Reset / Mode switch.</div>
        </div>

        <div class="divider"></div>

        <div class="grid">
          <div class="hint"><b>Never Have I Ever</b> â€“ Add one question:</div>
          <input id="nhieNew" placeholder="e.g. Never have I ever skipped class"/>
          <div class="row">
            <button class="btn selected" id="addNhie">Add</button>
            <button class="btn danger" id="clearNhie">Clear All</button>
          </div>
          <div class="list" id="nhieList"></div>
        </div>

        <div class="divider"></div>

        <div class="grid">
          <div class="hint"><b>Pick One</b> â€“ Easy add:</div>
          <input id="pickQ" placeholder="Question (optional) e.g. Pick one"/>
          <div class="miniRow">
            <input id="pickO1" placeholder="Option 1"/>
            <input id="pickO2" placeholder="Option 2"/>
          </div>
          <div class="row">
            <button class="btn selected" id="addPick">Add</button>
            <button class="btn danger" id="clearPick">Clear All</button>
          </div>
          <div class="list" id="pickList"></div>
        </div>

        <!-- âœ… Truth/Dare manage -->
        <div class="divider"></div>
        <div class="grid">
          <div class="hint"><b>Truth</b> â€“ Add unlimited:</div>
          <input id="truthNew" placeholder="e.g. Whatâ€™s your biggest fear?" />
          <div class="row">
            <button class="btn selected" id="addTruth">Add</button>
            <button class="btn danger" id="clearTruth">Clear All</button>
          </div>
          <div class="list" id="truthList"></div>
        </div>

        <div class="divider"></div>
        <div class="grid">
          <div class="hint"><b>Dare</b> â€“ Add unlimited:</div>
          <input id="dareNew" placeholder="e.g. Do 10 push-ups right now" />
          <div class="row">
            <button class="btn selected" id="addDare">Add</button>
            <button class="btn danger" id="clearDare">Clear All</button>
          </div>
          <div class="list" id="dareList"></div>
        </div>

        <div class="divider"></div>

        <div class="row">
          <button class="btn ghost" id="loadSample">Load Sample</button>
          <button class="btn danger" id="wipeAll">Reset Everything</button>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    // ===========================
    // âœ… SUPABASE CONFIG
    // ===========================
    const SUPABASE_URL = "https://xgiryhgysebcskkyhmej.supabase.co";
    const SUPABASE_ANON_KEY = "sb_publishable_7WgNVc5MkpgJcoCj3iQArw_J4zcgtsg";

    import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
      auth: { persistSession: true, autoRefreshToken: true, detectSessionInUrl: true }
    });

    // ---------------------------
    // Utilities
    // ---------------------------
    const el = (id) => document.getElementById(id);
    const show = (id) => el(id).classList.add("show");
    const hide = (id) => el(id).classList.remove("show");
    const setText = (id, v) => el(id).textContent = v;
    const clampName = (s, fallback) => (String(s||"").trim() || fallback).slice(0, 24);

    function cleanRoomId(s){
      return (String(s||"").toUpperCase().trim().replace(/[^A-Z0-9]/g, "")).slice(0, 10);
    }
    function genRoomId(){
      const chars = "ABCDEFGHJKMNPQRSTUVWXYZ23456789";
      let out = "";
      for(let i=0;i<6;i++) out += chars[Math.floor(Math.random()*chars.length)];
      return out;
    }
    function deepClone(x){ return JSON.parse(JSON.stringify(x)); }

    function shuffle(arr){
      for(let i=arr.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [arr[i],arr[j]] = [arr[j],arr[i]];
      }
    }

    // âœ… buildOrder now supports shuffle ON/OFF
    function buildOrder(len, doShuffle=true){
      const order = Array.from({length:len}, (_,i)=>i);
      if(doShuffle) shuffle(order);
      return order;
    }

    function pickSampleIndices(total, want=10){
      const n = Math.min(total, want);
      const idx = Array.from({length: total}, (_,i)=>i);
      shuffle(idx);
      return idx.slice(0, n);
    }

    function nowISO(){ return new Date().toISOString(); }
    function fmtTime(ts){
      try{
        const d = new Date(ts);
        const hh = String(d.getHours()).padStart(2,"0");
        const mm = String(d.getMinutes()).padStart(2,"0");
        return `${hh}:${mm}`;
      }catch{ return ""; }
    }

    // ---------------------------
    // Questions (Manage) - local
    // ---------------------------
    const QKEY = "party_questions_local_v3"; // bumped
    const ADMIN_PASSWORD = "Admin@123";

    // âœ… shuffle settings stored locally
    const SKEY = "party_settings_local_v1";
    const settings = { shuffleNhie:true, shufflePick:true };

    function loadSettings(){
      try{
        const v = JSON.parse(localStorage.getItem(SKEY));
        if(v && typeof v === "object"){
          settings.shuffleNhie = v.shuffleNhie !== false;
          settings.shufflePick = v.shufflePick !== false;
        }
      }catch{}
    }
    function saveSettings(){
      localStorage.setItem(SKEY, JSON.stringify(settings));
    }

    const SAMPLE_Q = {
      nhie:[
        "Never have I ever lied to my parents",
        "Never have I ever ghosted someone",
        "Never have I ever skipped a class",
        "Never have I ever stalked someoneâ€™s profile"
      ],
      pick:[
        {q:"Pick one", o1:"Pizza", o2:"Burger"},
        {q:"Pick one", o1:"Netflix", o2:"YouTube"},
        {q:"Pick one", o1:"Beach", o2:"Mountains"}
      ],
      truth:[
        "Whatâ€™s the most embarrassing thing youâ€™ve done?",
        "Who was your first crush?",
        "Whatâ€™s your biggest insecurity?",
        "Whatâ€™s a secret youâ€™ve never told anyone?"
      ],
      dare:[
        "Do 10 squats right now",
        "Send a funny voice note to your friend (optional)",
        "Do your best dance for 10 seconds",
        "Say â€˜I love pizzaâ€™ in a dramatic voice"
      ]
    };

    const questions = { nhie:[], pick:[], truth:[], dare:[] };

    function loadQuestions(){
      // try v3
      try{
        const v = JSON.parse(localStorage.getItem(QKEY));
        if(!v) throw 0;
        questions.nhie = Array.isArray(v.nhie) ? v.nhie : [];
        questions.pick = Array.isArray(v.pick) ? v.pick : [];
        questions.truth = Array.isArray(v.truth) ? v.truth : [];
        questions.dare = Array.isArray(v.dare) ? v.dare : [];
        return;
      }catch{}

      // fallback old v2 if exists
      try{
        const old = JSON.parse(localStorage.getItem("party_questions_local_v2"));
        if(old && typeof old === "object"){
          questions.nhie = Array.isArray(old.nhie) ? old.nhie : deepClone(SAMPLE_Q.nhie);
          questions.pick = Array.isArray(old.pick) ? old.pick : deepClone(SAMPLE_Q.pick);
          questions.truth = deepClone(SAMPLE_Q.truth);
          questions.dare = deepClone(SAMPLE_Q.dare);
          saveQuestions();
          return;
        }
      }catch{}

      // default sample
      questions.nhie = deepClone(SAMPLE_Q.nhie);
      questions.pick = deepClone(SAMPLE_Q.pick);
      questions.truth = deepClone(SAMPLE_Q.truth);
      questions.dare = deepClone(SAMPLE_Q.dare);
      saveQuestions();
    }

    function saveQuestions(){
      localStorage.setItem(QKEY, JSON.stringify(questions));
    }

    // ---------------------------
    // Room doc model
    // ---------------------------
    function tdInit(){
      return {
        turn: "p1",           // turn owner (spins + later next)
        phase: "spin",        // spin | list | chosen
        type: null,           // truth | dare
        spinDeg: 0,           // âœ… wheel rotation degrees (stored)
        spinToken: null,      // âœ… changes each spin (for animation sync)
        sample: [],           // store text
        chosenText: "",
        chosenAt: null,
        chosenBy: null        // p1/p2 (who selected from cards)
      };
    }

    function makeNewRoomDoc({roomId, hostUid, hostName, q, shuffleCfg}){
      const sh = shuffleCfg || { nhie:true, pick:true };
      return {
        roomId,
        status: "waiting", // waiting | playing
        hostUid,
        players: {
          p1: { uid: hostUid, name: hostName },
          p2: { uid: "", name: "" }
        },
        mode: "nhie", // nhie | pick | td
        shuffle: sh, // âœ… store shuffle prefs in room
        idx: 0,
        order: buildOrder((q?.nhie||[]).length, sh.nhie),
        questions: q || {nhie:[], pick:[], truth:[], dare:[]},
        td: tdInit(),
        chat: [], // last 40
        state: {
          counts: {p1:0,p2:0},
          last: {p1:"â€”",p2:"â€”"},
          nhieTurn: "p1",
          nhieAnswered: {p1:false,p2:false},
          pickLast: {p1:"â€”",p2:"â€”"},
          pickTurn: "p1",
          pickAnswered: {p1:false,p2:false},
        },
        updatedAt: Date.now()
      };
    }

    // ---------------------------
    // Supabase Room API (rooms.id PK)
    // ---------------------------
    const RoomAPI = (() => {
      async function readRoom(roomId){
        const rid = cleanRoomId(roomId);
        const { data, error } = await supabase
          .from("rooms")
          .select("id, doc, version, updated_at")
          .eq("id", rid)
          .maybeSingle();
        if(error) throw error;
        return data || null;
      }

      async function createRoom({hostUid, hostName, q, shuffleCfg}){
        for(let t=0;t<8;t++){
          const roomId = genRoomId();
          const doc = makeNewRoomDoc({roomId, hostUid, hostName, q, shuffleCfg});
          const { error } = await supabase
            .from("rooms")
            .insert({ id: roomId, doc, version: 0 });
          if(!error) return { roomId, role:"p1" };
        }
        throw new Error("Could not create room. Try again.");
      }

      async function writeRoomCAS(roomId, expectedVersion, nextDoc){
        const { data, error } = await supabase
          .from("rooms")
          .update({ doc: nextDoc, version: expectedVersion + 1, updated_at: new Date().toISOString() })
          .eq("id", roomId)
          .eq("version", expectedVersion)
          .select("id")
          .maybeSingle();
        if(error) throw error;
        return !!data;
      }

      async function joinRoom({roomId, uid, name}){
        const rid = cleanRoomId(roomId);
        for(let attempt=0; attempt<8; attempt++){
          const row = await readRoom(rid);
          if(!row) throw new Error("Room not found");

          const doc = row.doc;

          if(doc.players?.p1?.uid === uid){
            doc.players.p1.name = name || doc.players.p1.name;
            doc.updatedAt = Date.now();
            const ok = await writeRoomCAS(rid, row.version, doc);
            if(ok) return { role:"p1", roomId: rid };
            continue;
          }
          if(doc.players?.p2?.uid === uid){
            doc.players.p2.name = name || doc.players.p2.name;
            doc.updatedAt = Date.now();
            const ok = await writeRoomCAS(rid, row.version, doc);
            if(ok) return { role:"p2", roomId: rid };
            continue;
          }

          if(doc.players?.p2?.uid) throw new Error("Room is full");

          doc.players.p2.uid = uid;
          doc.players.p2.name = name;
          doc.updatedAt = Date.now();

          const ok = await writeRoomCAS(rid, row.version, doc);
          if(ok) return { role:"p2", roomId: rid };
        }
        throw new Error("Join failed. Try again.");
      }

      async function patchRoom(roomId, patchFn){
        const rid = cleanRoomId(roomId);
        for(let attempt=0; attempt<10; attempt++){
          const row = await readRoom(rid);
          if(!row) throw new Error("Room not found");

          const doc = deepClone(row.doc);
          const next = patchFn(doc);
          next.updatedAt = Date.now();

          const ok = await writeRoomCAS(rid, row.version, next);
          if(ok) return;
        }
        throw new Error("Update failed (conflict). Try again.");
      }

      async function leaveRoom(roomId, uid){
        const rid = cleanRoomId(roomId);
        for(let attempt=0; attempt<8; attempt++){
          const row = await readRoom(rid);
          if(!row) return;

          const doc = deepClone(row.doc);
          const p1 = doc.players?.p1?.uid;
          const p2 = doc.players?.p2?.uid;

          if(p1 === uid){
            const { error } = await supabase.from("rooms").delete().eq("id", rid);
            if(error) throw error;
            return;
          }

          if(p2 === uid){
            doc.players.p2 = {uid:"", name:""};
            doc.status = "waiting";
            doc.idx = 0;

            doc.state.last = {p1:"â€”",p2:"â€”"};
            doc.state.nhieAnswered = {p1:false,p2:false};
            doc.state.nhieTurn = "p1";

            doc.state.pickLast = {p1:"â€”",p2:"â€”"};
            doc.state.pickAnswered = {p1:false,p2:false};
            doc.state.pickTurn = "p1";

            doc.td = tdInit();
            doc.chat = [];

            doc.updatedAt = Date.now();
            const ok = await writeRoomCAS(rid, row.version, doc);
            if(ok) return;
          }else{
            return;
          }
        }
      }

      function subscribeRoom(roomId, cb){
        const rid = cleanRoomId(roomId);
        let cancelled = false;

        async function fetchOnce(){
          try{
            const row = await readRoom(rid);
            if(!cancelled) cb(row ? row.doc : null);
          }catch(e){
            console.error(e);
          }
        }

        fetchOnce();
        const poll = setInterval(fetchOnce, 1500);

        const channel = supabase
          .channel("room-" + rid)
          .on(
            "postgres_changes",
            { event: "*", schema: "public", table: "rooms", filter: `id=eq.${rid}` },
            fetchOnce
          )
          .subscribe();

        return () => {
          cancelled = true;
          clearInterval(poll);
          supabase.removeChannel(channel);
        };
      }

      return { createRoom, joinRoom, subscribeRoom, patchRoom, leaveRoom };
    })();

    // ---------------------------
    // Client state
    // ---------------------------
    const client = { uid:"", roomId:"", role:"", room:null, unsub:null };

    function setScreen(name){
      ["screenHome","screenLobby","screenGame"].forEach(id => hide(id));
      show(name);
      const isGame = name === "screenGame";
      el("reset").disabled = !isGame;
      el("next").disabled  = !isGame;
      el("modeSeg").style.display = isGame ? "flex" : "none";
    }

    function showHomeError(msg){
      el("homeErr").style.display = msg ? "block" : "none";
      el("homeErr").textContent = msg || "";
    }
    function showLobbyError(msg){
      el("lobbyErr").style.display = msg ? "block" : "none";
      el("lobbyErr").textContent = msg || "";
    }

    function buildShareLink(roomId){
      const u = new URL(window.location.href);
      u.searchParams.set("room", cleanRoomId(roomId));
      return u.toString();
    }

    function cleanupRoom(){
      if(client.unsub) client.unsub();
      client.unsub = null;
      client.room = null;
      client.roomId = "";
      client.role = "";
    }

    function subscribeRoom(roomId){
      if(client.unsub) client.unsub();
      client.unsub = RoomAPI.subscribeRoom(roomId, (doc) => {
        client.room = doc;
        if(!doc){
          cleanupRoom();
          setScreen("screenHome");
          showHomeError("Room ended or deleted.");
          return;
        }
        renderFromRoom(doc);
      });
    }

    function otherRole(r){ return r === "p1" ? "p2" : "p1"; }

    // ---------------------------
    // Render helpers
    // ---------------------------
    function getQ(room){
      const q = room.questions || {};
      return {
        nhie: Array.isArray(q.nhie) ? q.nhie : [],
        pick: Array.isArray(q.pick) ? q.pick : [],
        truth: Array.isArray(q.truth) ? q.truth : [],
        dare: Array.isArray(q.dare) ? q.dare : []
      };
    }

    function setProgress(room){
      const q = getQ(room);
      let pct = 0;
      if(room.mode === "nhie"){
        const total = q.nhie.length;
        pct = total ? Math.round(((room.idx+1)/total)*100) : 0;
      }else if(room.mode === "pick"){
        const total = q.pick.length;
        pct = total ? Math.round(((room.idx+1)/total)*100) : 0;
      }else{
        pct = 0;
      }
      el("progFill").style.width = pct + "%";
    }

    function setModeUI(room){
      el("tabNhie").classList.toggle("active", room.mode === "nhie");
      el("tabPick").classList.toggle("active", room.mode === "pick");
      el("tabTD").classList.toggle("active", room.mode === "td");

      el("nhieArea").style.display = room.mode === "nhie" ? "block" : "none";
      el("pickArea").style.display = room.mode === "pick" ? "block" : "none";
      el("tdArea").style.display   = room.mode === "td"   ? "block" : "none";

      el("bottomBar").style.display = room.mode === "td" ? "none" : "flex";
    }

    function getCurrentItem(room){
      const q = getQ(room);
      const list = room.mode === "nhie" ? q.nhie : q.pick;
      if(!list.length) return null;
      const realIdx = room.order?.[room.idx] ?? 0;
      return list[realIdx] ?? null;
    }

    function updateNhieUI(room){
      const a1 = room.state.last.p1 || "â€”";
      const a2 = room.state.last.p2 || "â€”";
      el("p1SelMini").textContent = (room.players.p1.name || "Player 1") + " â€¢ Selection";
      el("p2SelMini").textContent = (room.players.p2.name || "Player 2") + " â€¢ Selection";
      setText("p1SelBox", a1); setText("p2SelBox", a2);
      el("p1SelBox").classList.toggle("selected", a1 !== "â€”");
      el("p2SelBox").classList.toggle("selected", a2 !== "â€”");

      const d1 = !!room.state.nhieAnswered.p1;
      const d2 = !!room.state.nhieAnswered.p2;
      setText("p1Badge", d1 ? "Done" : "Pending");
      setText("p2Badge", d2 ? "Done" : "Pending");
      el("p1Badge").classList.toggle("done", d1);
      el("p2Badge").classList.toggle("done", d2);

      const turn = room.state.nhieTurn;
      setText("nhieTurnPill", "Turn: " + (turn==="p1" ? (room.players.p1.name||"P1") : (room.players.p2.name||"P2")));

      const both = d1 && d2;
      if(both){
        setText("nhieStatus", "Both answered âœ… Host can tap Next.");
        el("nhieHave").disabled = true;
        el("nhieNever").disabled = true;
      }else{
        const tName = turn==="p1" ? (room.players.p1.name||"P1") : (room.players.p2.name||"P2");
        setText("nhieStatus", tName + " select: I Have / I Never");
        const myTurn = client.role === turn;
        el("nhieHave").disabled = !myTurn;
        el("nhieNever").disabled = !myTurn;
      }

      const sel = room.state.last[turn];
      el("nhieHave").classList.toggle("selected", sel === "I Have");
      el("nhieNever").classList.toggle("selected", sel === "I Never");
    }

    function updatePickUI(room){
      const t = room.state.pickTurn;
      setText("pickTurnPill", "Turn: " + (t==="p1" ? (room.players.p1.name||"P1") : (room.players.p2.name||"P2")));

      const v1 = room.state.pickLast.p1 || "â€”";
      const v2 = room.state.pickLast.p2 || "â€”";
      setText("p1PickBox", v1);
      setText("p2PickBox", v2);
      el("p1PickBox").classList.toggle("selected", v1 !== "â€”");
      el("p2PickBox").classList.toggle("selected", v2 !== "â€”");

      const a1 = !!room.state.pickAnswered.p1;
      const a2 = !!room.state.pickAnswered.p2;
      const both = a1 && a2;

      if(both){
        setText("pickStatus", "Both answered âœ… Host can tap Next.");
        el("opt1Btn").disabled = true;
        el("opt2Btn").disabled = true;
      }else{
        const tName = t==="p1" ? (room.players.p1.name||"P1") : (room.players.p2.name||"P2");
        setText("pickStatus", tName + " select an option.");
        const myTurn = client.role === t;
        el("opt1Btn").disabled = !myTurn;
        el("opt2Btn").disabled = !myTurn;
      }

      const sel = room.state.pickLast[t];
      const o1 = el("opt1Btn").textContent || "Option 1";
      const o2 = el("opt2Btn").textContent || "Option 2";
      el("opt1Btn").classList.toggle("selected", sel && sel !== "â€”" && sel === o1);
      el("opt2Btn").classList.toggle("selected", sel && sel !== "â€”" && sel === o2);
    }

    function renderChat(room){
      const msgs = Array.isArray(room.chat) ? room.chat : [];
      const wrap = el("chatMsgs");
      if(!wrap) return;
      if(!msgs.length){
        wrap.innerHTML = `<div class="tiny">No messages yet. Say something ðŸ˜„</div>`;
        return;
      }
      wrap.innerHTML = msgs.map(m => {
        const name = (m?.name || "Player").toString().slice(0,24);
        const t = m?.ts || null;
        const time = t ? fmtTime(t) : "";
        const text = (m?.text || "").toString()
          .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
          .replaceAll('"',"&quot;").replaceAll("'","&#039;");
        return `
          <div class="msg">
            <div class="msgTop">
              <div class="msgName">${name}</div>
              <div class="msgTime">${time}</div>
            </div>
            <div>${text}</div>
          </div>
        `;
      }).join("");
      wrap.scrollTop = wrap.scrollHeight;
    }

    // âœ… wheel animation guard (local only) + smooth remote animation memory
    let lastSpinTokenLocal = null;
    let lastDegLocal = 0;

    function setBadge(type){
      const b = el("tdResultBadge");
      b.classList.remove("truth","dare");
      if(type === "truth"){
        b.classList.add("truth");
        b.textContent = "TRUTH";
      }else if(type === "dare"){
        b.classList.add("dare");
        b.textContent = "DARE";
      }else{
        b.textContent = "â€”";
      }
    }

    function updateTDUI(room){
      const q = getQ(room);
      room.td = room.td || tdInit();

      const turn = room.td.turn || "p1";
      const turnName = turn==="p1" ? (room.players.p1.name||"P1") : (room.players.p2.name||"P2");
      setText("tdTurnPill", `Turn: ${turnName}`);
      setText("tdPhasePill", `Phase: ${room.td.phase || "spin"}`);

      const phase = room.td.phase || "spin";
      const type = room.td.type; // truth/dare
      setBadge(type);

      const other = otherRole(turn);

      const canSpin = (phase === "spin") && (client.role === turn);
      const canShuffle = (phase === "list") && (client.role === other);
      const canNext = (phase === "chosen") && (client.role === turn);

      el("tdSpinBtn").disabled = !canSpin;
      el("tdShuffleBtn").disabled = !canShuffle;
      el("tdNextBtn").disabled = !canNext;

      // âœ… Wheel rotate (smooth sync via td.spinDeg + td.spinToken)
      const wheel = el("wheel");
      const token = room.td.spinToken || null;
      const deg = Number(room.td.spinDeg || 0);

      if(token && token !== lastSpinTokenLocal){
        lastSpinTokenLocal = token;

        wheel.style.transition = "none";
        wheel.style.transform = `rotate(${lastDegLocal}deg)`;
        wheel.offsetHeight; // reflow

        wheel.style.transition = "transform 2.5s cubic-bezier(.12,.85,.22,1)";
        wheel.style.transform = `rotate(${deg}deg)`;
        lastDegLocal = deg;

      }else if(!token){
        wheel.style.transition = "transform 2.5s cubic-bezier(.12,.85,.22,1)";
        wheel.style.transform = `rotate(0deg)`;
        lastDegLocal = 0;
      }

      if(phase === "spin"){
        setText("qText", "ðŸŽ¡ Spin the wheel");
        setText("qMeta", `Truth/Dare â€¢ ${turnName} spins`);
        setText("tdHint", `${turnName} spin karega. Dusra player cards me se select karega.`);
        setBadge(null);
      }else if(phase === "list"){
        setText("qText", "Pick 1 card");
        setText("qMeta", `Truth/Dare â€¢ cards`);
        setText("tdHint", `Select 1 card. (Shuffle available)`);
      }else{
        const chosen = room.td.chosenText || "â€”";
        setText("qText", chosen);
        setText("qMeta", `Truth/Dare â€¢ selected`);
        setText("tdHint", `Done? Turn player "Next Spin" dabaye.`);
      }

      const cardsWrap = el("tdCards");
      const sample = Array.isArray(room.td.sample) ? room.td.sample : [];
      const chosenText = room.td.chosenText || "";

      if(phase === "spin"){
        cardsWrap.innerHTML = `<div class="tiny">Spin ke baad yahan 10 cards dikhenge.</div>`;
      }else if(phase === "list"){
        if(!sample.length){
          cardsWrap.innerHTML = `<div class="tiny">No cards found. Add more in Manage â†’ Truth/Dare.</div>`;
        }else{
          const otherCanClick = (client.role === other);
          cardsWrap.innerHTML = sample.map((t,i)=> {
            const safe = String(t||"").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
              .replaceAll('"',"&quot;").replaceAll("'","&#039;");
            return `<button class="cardBtn" data-tdpick="${i}" ${otherCanClick ? "" : "disabled"}>${safe}</button>`;
          }).join("");
        }
      }else{
        if(chosenText){
          const safe = String(chosenText).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
            .replaceAll('"',"&quot;").replaceAll("'","&#039;");
          cardsWrap.innerHTML = `<button class="cardBtn selected" disabled>${safe}</button>`;
        }else{
          cardsWrap.innerHTML = `<div class="tiny">â€”</div>`;
        }
      }

      renderChat(room);
      setProgress(room);
    }

    function renderFromRoom(room){
      setText("lobbyRoomId", room.roomId);
      setText("lobbyP1", room.players.p1.name || "Waitingâ€¦");
      setText("lobbyP2", room.players.p2.name || "Waitingâ€¦");
      setText("lobbyRolePill", "Role: " + (client.role || "â€”"));
      el("shareLink").value = buildShareLink(room.roomId);

      const bothJoined = !!(room.players.p1.uid && room.players.p2.uid);
      el("startGame").disabled = !(bothJoined && client.role === "p1");

      if(room.status === "waiting"){
        setScreen("screenLobby");
        el("lobbyHint").textContent = bothJoined
          ? "Both players joined âœ… Host can start the game."
          : "Waiting for Player 2 to joinâ€¦";
      }
      if(room.status === "playing"){
        setScreen("screenGame");
      }

      setText("gameRoomId", room.roomId);
      setText("gameMeRole", client.role || "â€”");
      if(room.status !== "playing") return;

      setText("p1Name", room.players.p1.name || "Player 1");
      setText("p2Name", room.players.p2.name || "Player 2");
      setText("p1Name2", room.players.p1.name || "Player 1");
      setText("p2Name2", room.players.p2.name || "Player 2");

      room.td = room.td || tdInit();
      room.chat = Array.isArray(room.chat) ? room.chat : [];

      setModeUI(room);

      const q = getQ(room);
      const item = getCurrentItem(room);

      if(room.mode === "nhie" || room.mode === "pick"){
        setText("p1Count", room.state.counts.p1 || 0);
        setText("p2Count", room.state.counts.p2 || 0);

        const nhieDone = room.state.nhieAnswered.p1 && room.state.nhieAnswered.p2;
        el("scoreP1").classList.toggle("active", room.mode==="nhie" && room.state.nhieTurn==="p1" && !nhieDone);
        el("scoreP2").classList.toggle("active", room.mode==="nhie" && room.state.nhieTurn==="p2" && !nhieDone);
        if(room.mode!=="nhie"){ el("scoreP1").classList.remove("active"); el("scoreP2").classList.remove("active"); }

        if(!item){
          setText("qText", "No questions yet.");
          setText("qMeta", "Open Manage â†’ add questions");
          el("opt1Btn").textContent = "Option 1";
          el("opt2Btn").textContent = "Option 2";
          setProgress(room);
          updateNhieUI(room);
          updatePickUI(room);
        }else if(room.mode === "nhie"){
          setText("qText", item);
          setText("qMeta", `Never Have I Ever â€¢ ${room.idx+1}/${q.nhie.length}`);
          setProgress(room);
          updateNhieUI(room);
        }else{
          const qq = item.q?.trim() ? item.q.trim() : "Pick one";
          setText("qText", qq);
          setText("qMeta", `Pick One â€¢ ${room.idx+1}/${q.pick.length}`);
          el("opt1Btn").textContent = item.o1 || "Option 1";
          el("opt2Btn").textContent = item.o2 || "Option 2";
          setProgress(room);
          updatePickUI(room);
        }

        el("next").disabled = !(client.role==="p1");
        el("reset").disabled = !(client.role==="p1");
      }

      if(room.mode === "td"){
        updateTDUI(room);
      }
    }

    // ---------------------------
    // Room flows
    // ---------------------------
    async function createRoomFlow(){
      showHomeError("");
      const myName = clampName(el("myNameCreate").value, "Player 1");
      try{
        const q = deepClone(questions);
        const { roomId, role } = await RoomAPI.createRoom({
          hostUid: client.uid,
          hostName: myName,
          q,
          shuffleCfg: { nhie: settings.shuffleNhie, pick: settings.shufflePick }
        });
        client.role = role;
        client.roomId = roomId;
        setText("topSub", "Room created. Share link and wait for friend.");
        subscribeRoom(roomId);
      }catch(err){
        console.error(err);
        showHomeError(err?.message || "Failed to create room");
      }
    }

    async function joinRoomFlow(roomIdFromUrl){
      showHomeError("");
      const roomId = cleanRoomId(roomIdFromUrl || el("roomIdJoin").value || "");
      const myName = clampName(el("myNameJoin").value, "Player 2");
      if(!roomId) return showHomeError("Please enter Room code (example: AB12CD).");

      try{
        const { role, roomId: rid } = await RoomAPI.joinRoom({ roomId, uid: client.uid, name: myName });
        client.role = role;
        client.roomId = rid;
        setText("topSub", "Joined room. Waiting for host to start.");
        subscribeRoom(rid);
      }catch(err){
        console.error(err);
        showHomeError(err?.message || "Failed to join room");
      }
    }

    async function startGameFlow(){
      showLobbyError("");
      if(client.role !== "p1") return;
      if(!client.roomId) return;

      try{
        const q = deepClone(questions);
        await RoomAPI.patchRoom(client.roomId, (doc) => {
          const both = doc.players.p1.uid && doc.players.p2.uid;
          if(!both) return doc;

          doc.shuffle = doc.shuffle || { nhie:true, pick:true };

          doc.questions = q;
          doc.status = "playing";
          doc.mode = doc.mode || "nhie";

          const len = doc.mode === "nhie" ? (q.nhie||[]).length : (q.pick||[]).length;
          const doShuffle = doc.mode === "nhie" ? doc.shuffle.nhie : doc.shuffle.pick;
          doc.order = buildOrder(len, doShuffle);
          doc.idx = 0;

          doc.state.last = {p1:"â€”",p2:"â€”"};
          doc.state.nhieAnswered = {p1:false,p2:false};
          doc.state.nhieTurn = "p1";

          doc.state.pickLast = {p1:"â€”",p2:"â€”"};
          doc.state.pickAnswered = {p1:false,p2:false};
          doc.state.pickTurn = "p1";

          doc.td = tdInit();
          doc.chat = [];

          return doc;
        });
      }catch(err){
        console.error(err);
        showLobbyError(err?.message || "Cannot start");
      }
    }

    async function leaveRoomFlow(){
      try{
        if(client.roomId){
          await RoomAPI.leaveRoom(client.roomId, client.uid);
        }
      }catch(e){ console.error(e); }
      cleanupRoom();
      setScreen("screenHome");
    }

    async function setMode(mode){
      if(client.role !== "p1") return;
      if(!client.roomId) return;

      await RoomAPI.patchRoom(client.roomId, (doc) => {
        doc.mode = mode;
        doc.shuffle = doc.shuffle || { nhie:true, pick:true };

        const q = getQ(doc);

        if(mode === "nhie" || mode === "pick"){
          const len = mode === "nhie" ? q.nhie.length : q.pick.length;
          const doShuffle = mode === "nhie" ? doc.shuffle.nhie : doc.shuffle.pick;

          doc.order = buildOrder(len, doShuffle);
          doc.idx = 0;

          doc.state.last = {p1:"â€”",p2:"â€”"};
          doc.state.nhieAnswered = {p1:false,p2:false};
          doc.state.nhieTurn = "p1";

          doc.state.pickLast = {p1:"â€”",p2:"â€”"};
          doc.state.pickAnswered = {p1:false,p2:false};
          doc.state.pickTurn = "p1";
        }else{
          doc.td = doc.td || tdInit();
          doc.td.turn = "p1";
          doc.td.phase = "spin";
          doc.td.type = null;
          doc.td.spinDeg = 0;
          doc.td.spinToken = null;
          doc.td.sample = [];
          doc.td.chosenText = "";
          doc.td.chosenBy = null;
          doc.td.chosenAt = null;
        }
        return doc;
      });
    }

    async function nhieSelect(answerText){
      if(!client.roomId) return;
      await RoomAPI.patchRoom(client.roomId, (doc) => {
        if(doc.status !== "playing") return doc;
        if(doc.mode !== "nhie") return doc;

        const turn = doc.state.nhieTurn;
        if(client.role !== turn) return doc;
        if(doc.state.nhieAnswered[turn]) return doc;

        doc.state.last[turn] = answerText;
        doc.state.nhieAnswered[turn] = true;

        if(answerText === "I Have"){
          doc.state.counts[turn] = (doc.state.counts[turn] || 0) + 1;
        }

        const other = (turn === "p1") ? "p2" : "p1";
        if(!doc.state.nhieAnswered[other]){
          doc.state.nhieTurn = other;
        }
        return doc;
      });
    }

    async function pickSelect(optionText){
      if(!client.roomId) return;
      await RoomAPI.patchRoom(client.roomId, (doc) => {
        if(doc.status !== "playing") return doc;
        if(doc.mode !== "pick") return doc;

        const turn = doc.state.pickTurn;
        if(client.role !== turn) return doc;
        if(doc.state.pickAnswered[turn]) return doc;

        doc.state.pickLast[turn] = optionText;
        doc.state.pickAnswered[turn] = true;

        const other = (turn === "p1") ? "p2" : "p1";
        if(!doc.state.pickAnswered[other]){
          doc.state.pickTurn = other;
        }
        return doc;
      });
    }

    async function nextQuestion(){
      if(client.role !== "p1") return;
      if(!client.roomId) return;

      await RoomAPI.patchRoom(client.roomId, (doc) => {
        if(doc.status !== "playing") return doc;
        if(doc.mode !== "nhie" && doc.mode !== "pick") return doc;

        const q = getQ(doc);
        const len = doc.mode === "nhie" ? q.nhie.length : q.pick.length;
        if(!len) return doc;

        if(doc.mode === "nhie"){
          if(!(doc.state.nhieAnswered.p1 && doc.state.nhieAnswered.p2)) return doc;
        }else{
          if(!(doc.state.pickAnswered.p1 && doc.state.pickAnswered.p2)) return doc;
        }

        doc.idx = (doc.idx + 1) % len;

        doc.state.last = {p1:"â€”",p2:"â€”"};
        doc.state.nhieAnswered = {p1:false,p2:false};
        doc.state.nhieTurn = "p1";

        doc.state.pickLast = {p1:"â€”",p2:"â€”"};
        doc.state.pickAnswered = {p1:false,p2:false};
        doc.state.pickTurn = "p1";

        return doc;
      });
    }

    async function resetGame(){
      if(client.role !== "p1") return;
      if(!client.roomId) return;

      await RoomAPI.patchRoom(client.roomId, (doc) => {
        if(doc.mode === "td"){
          doc.td = tdInit();
          doc.chat = [];
          return doc;
        }

        const q = getQ(doc);
        const len = doc.mode === "nhie" ? q.nhie.length : q.pick.length;

        doc.shuffle = doc.shuffle || { nhie:true, pick:true };
        const doShuffle = doc.mode === "nhie" ? doc.shuffle.nhie : doc.shuffle.pick;

        doc.state.counts = {p1:0,p2:0};
        doc.idx = 0;
        doc.order = buildOrder(len, doShuffle);

        doc.state.last = {p1:"â€”",p2:"â€”"};
        doc.state.nhieAnswered = {p1:false,p2:false};
        doc.state.nhieTurn = "p1";

        doc.state.pickLast = {p1:"â€”",p2:"â€”"};
        doc.state.pickAnswered = {p1:false,p2:false};
        doc.state.pickTurn = "p1";

        return doc;
      });
    }

    // ---------------------------
    // Truth/Dare actions (Wheel-based)
    // Turn player spins. Other player selects.
    // ---------------------------
    function tdPool(doc){
      const q = getQ(doc);
      return { truth: q.truth, dare: q.dare };
    }

    // NOTE: wheel is decorative now; we force result via weighted logic.
    async function tdSpin(){
      if(!client.roomId) return;
      await RoomAPI.patchRoom(client.roomId, (doc) => {
        if(doc.status !== "playing") return doc;
        if(doc.mode !== "td") return doc;

        doc.td = doc.td || tdInit();
        const turn = doc.td.turn || "p1";
        const other = otherRole(turn);

        if(doc.td.phase !== "spin") return doc;
        if(client.role !== turn) return doc;

        const base = 360 * (6 + Math.floor(Math.random()*3)); // 6-8 rounds

        // âœ… Weighted result: ~90% TRUTH, ~10% DARE
        const wantType = (Math.random() < 0.90) ? "truth" : "dare";

        // âœ… Stop angle chosen so type matches WANT
        // truth => deg%360 in [180..359]
        // dare  => deg%360 in [0..179]
        const stop = (wantType === "truth")
          ? (180 + Math.floor(Math.random()*180))
          : Math.floor(Math.random()*180);

        const deg = base + stop;

        const type = wantType;
        const pool = tdPool(doc)[type] || [];
        const pick = pickSampleIndices(pool.length, 10);
        const sample = pick.map(i => pool[i]);

        doc.td.spinDeg = deg;
        doc.td.spinToken = Date.now() + "_" + Math.random().toString(16).slice(2);
        doc.td.type = type;
        doc.td.sample = sample;
        doc.td.phase = "list";
        doc.td.chosenText = "";
        doc.td.chosenBy = null;
        doc.td.chosenAt = null;

        return doc;
      });
    }

    async function tdShuffleSample(){
      if(!client.roomId) return;
      await RoomAPI.patchRoom(client.roomId, (doc) => {
        if(doc.status !== "playing") return doc;
        if(doc.mode !== "td") return doc;

        doc.td = doc.td || tdInit();
        const turn = doc.td.turn || "p1";
        const other = otherRole(turn);

        if(doc.td.phase !== "list") return doc;
        if(client.role !== other) return doc;

        const type = doc.td.type;
        if(type !== "truth" && type !== "dare") return doc;

        const pool = tdPool(doc)[type] || [];
        const pick = pickSampleIndices(pool.length, 10);
        doc.td.sample = pick.map(i => pool[i]);
        return doc;
      });
    }

    async function tdChoose(sampleIndex){
      if(!client.roomId) return;
      await RoomAPI.patchRoom(client.roomId, (doc) => {
        if(doc.status !== "playing") return doc;
        if(doc.mode !== "td") return doc;

        doc.td = doc.td || tdInit();
        const turn = doc.td.turn || "p1";
        const other = otherRole(turn);

        if(doc.td.phase !== "list") return doc;
        if(client.role !== other) return doc;

        const sample = Array.isArray(doc.td.sample) ? doc.td.sample : [];
        const txt = sample[sampleIndex];
        if(!txt) return doc;

        doc.td.chosenText = txt;
        doc.td.chosenBy = other;
        doc.td.chosenAt = nowISO();
        doc.td.phase = "chosen";

        return doc;
      });
    }

    async function tdNextSpin(){
      if(!client.roomId) return;
      await RoomAPI.patchRoom(client.roomId, (doc) => {
        if(doc.status !== "playing") return doc;
        if(doc.mode !== "td") return doc;

        doc.td = doc.td || tdInit();
        const turn = doc.td.turn || "p1";

        if(doc.td.phase !== "chosen") return doc;
        if(client.role !== turn) return doc;

        doc.td.turn = otherRole(turn); // swap turn
        doc.td.phase = "spin";
        doc.td.type = null;
        doc.td.sample = [];
        doc.td.chosenText = "";
        doc.td.chosenBy = null;
        doc.td.chosenAt = null;
        return doc;
      });
    }

    async function chatSend(){
      if(!client.roomId) return;
      const text = (el("chatInput").value || "").trim();
      if(!text) return;
      el("chatInput").value = "";

      await RoomAPI.patchRoom(client.roomId, (doc) => {
        if(doc.status !== "playing") return doc;
        doc.chat = Array.isArray(doc.chat) ? doc.chat : [];

        const myName = client.role==="p1" ? (doc.players.p1.name||"P1") : (doc.players.p2.name||"P2");
        const msg = {
          id: `${Date.now()}_${Math.random().toString(16).slice(2)}`,
          uid: client.uid,
          role: client.role,
          name: myName,
          text: text.slice(0, 220),
          ts: nowISO()
        };

        doc.chat.push(msg);
        if(doc.chat.length > 40) doc.chat = doc.chat.slice(-40);
        return doc;
      });
    }

    // ---------------------------
    // Manage Sheet
    // ---------------------------
    function escapeHtml(s){
      return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
        .replaceAll('"',"&quot;").replaceAll("'","&#039;");
    }

    function renderLists(){
      el("nhieList").innerHTML = questions.nhie.length
        ? questions.nhie.map((q,i)=>`
          <div class="listItem">
            <div>${escapeHtml(q)}</div>
            <button class="del" data-del-nhie="${i}">Delete</button>
          </div>
        `).join("")
        : `<div class="tiny">No NHIE questions.</div>`;

      el("pickList").innerHTML = questions.pick.length
        ? questions.pick.map((p,i)=>`
          <div class="listItem">
            <div><b>${escapeHtml(p.o1||"Option 1")}</b> vs <b>${escapeHtml(p.o2||"Option 2")}</b></div>
            <button class="del" data-del-pick="${i}">Delete</button>
          </div>
        `).join("")
        : `<div class="tiny">No Pick One questions.</div>`;

      el("truthList").innerHTML = questions.truth.length
        ? questions.truth.map((t,i)=>`
          <div class="listItem">
            <div>${escapeHtml(t)}</div>
            <button class="del" data-del-truth="${i}">Delete</button>
          </div>
        `).join("")
        : `<div class="tiny">No Truth questions.</div>`;

      el("dareList").innerHTML = questions.dare.length
        ? questions.dare.map
